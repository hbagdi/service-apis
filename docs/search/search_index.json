{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Service APIs is an open source project managed by the SIG-NETWORK community. The project's goal is to evolve service networking APIs within the Kubernetes ecosystem. Service APIs provide interfaces to expose Kubernetes applications - Services, Ingress, and more. What is the goal of Service APIs? Service APIs aims to improve service networking by providing expressive, extensible, role-oriented interfaces that are implemented by many vendors and have broad industry support. Service APIs is a collection of API resources - Service , GatewayClass , Gateway , HTTPRoute , TCPRoute , etc. Together these resources model a wide variety of networking use-cases. How do Service APIs improve upon current standards like Ingress? More expressive - They express more core functionality for things like header-based matching, traffic weighting, and other capabilities that were only possible in Ingress through custom means. More extensible - They allow for custom resources to be linked at various layers of the API. This allows for more granular customization at the appropriate places within the API structure. Role oriented - They are separated into different API resources that map to the common roles for running applications on Kubernetes. Generic - This isn't an improvement but rather something that should stay the same. Just as Ingress is a universal specification with numerous implementations , Service APIs are designed to be a portable specification supported by many implementations. Some other notable capabilities include \u2026 Shared Gateways - They allow the sharing of load balancers and VIPs by permitting independent Route resources to bind to the same Gateway. This allows teams to share infrastructure safely without requiring direct coordination. Typed backend references - With typed backend references Routes can reference Kubernetes Services, but also any kind of Kubernetes resource that is designed to be a Gateway backend. Cross-Namespace references - Routes across different Namespaces can bind to Gateways. This allows for shared networking infrastructure despite Namespace segmentation for workloads. Classes - GatewayClasses formalize types of load balancing implementations. These classes make it easy and explicit for users to understand what kind of capabilities are available as a resource model itself. Where to get started To get started, please read through API overview . These documents give the necessary background to understand the API and the use-cases it targets. Once you have a good understanding of the API at a higher-level, please follow one of our guides to dive deeper into different parts of the API. For a complete API reference, please refer to: API reference Go docs for the package How to get involved This project has many contributors, and we welcome anybody and everybody to get involved. Join our weekly meetings, file issues, or ask questions in Slack. No contribution is too small - even opinions matter! Weekly meeting schedule Service APIs Slack Enhancement requests Project owners","title":"Introduction"},{"location":"#introduction","text":"Service APIs is an open source project managed by the SIG-NETWORK community. The project's goal is to evolve service networking APIs within the Kubernetes ecosystem. Service APIs provide interfaces to expose Kubernetes applications - Services, Ingress, and more.","title":"Introduction"},{"location":"#what-is-the-goal-of-service-apis","text":"Service APIs aims to improve service networking by providing expressive, extensible, role-oriented interfaces that are implemented by many vendors and have broad industry support. Service APIs is a collection of API resources - Service , GatewayClass , Gateway , HTTPRoute , TCPRoute , etc. Together these resources model a wide variety of networking use-cases. How do Service APIs improve upon current standards like Ingress? More expressive - They express more core functionality for things like header-based matching, traffic weighting, and other capabilities that were only possible in Ingress through custom means. More extensible - They allow for custom resources to be linked at various layers of the API. This allows for more granular customization at the appropriate places within the API structure. Role oriented - They are separated into different API resources that map to the common roles for running applications on Kubernetes. Generic - This isn't an improvement but rather something that should stay the same. Just as Ingress is a universal specification with numerous implementations , Service APIs are designed to be a portable specification supported by many implementations. Some other notable capabilities include \u2026 Shared Gateways - They allow the sharing of load balancers and VIPs by permitting independent Route resources to bind to the same Gateway. This allows teams to share infrastructure safely without requiring direct coordination. Typed backend references - With typed backend references Routes can reference Kubernetes Services, but also any kind of Kubernetes resource that is designed to be a Gateway backend. Cross-Namespace references - Routes across different Namespaces can bind to Gateways. This allows for shared networking infrastructure despite Namespace segmentation for workloads. Classes - GatewayClasses formalize types of load balancing implementations. These classes make it easy and explicit for users to understand what kind of capabilities are available as a resource model itself.","title":"What is the goal of Service APIs?"},{"location":"#where-to-get-started","text":"To get started, please read through API overview . These documents give the necessary background to understand the API and the use-cases it targets. Once you have a good understanding of the API at a higher-level, please follow one of our guides to dive deeper into different parts of the API. For a complete API reference, please refer to: API reference Go docs for the package","title":"Where to get started"},{"location":"#how-to-get-involved","text":"This project has many contributors, and we welcome anybody and everybody to get involved. Join our weekly meetings, file issues, or ask questions in Slack. No contribution is too small - even opinions matter! Weekly meeting schedule Service APIs Slack Enhancement requests Project owners","title":"How to get involved"},{"location":"api-overview/","text":"API Overview This document provides an overview of Service APIs. Roles and personas. There are 3 primary roles in Service APIs: Infrastructure Provider Cluster Operator Application Developer There could be a fourth role of Application Admin in some use cases. Please refer to the roles and personas section in the Security model for details. Resource model Note: Resources will initially live in the networking.x-k8s.io API group as Custom Resource Definitions (CRDs). Unqualified resource names will implicitly be in this API group. There are three main types of objects in our resource model: GatewayClass defines a set of gateways with a common configuration and behavior. Gateway requests a point where traffic can be translated to Services within the cluster. Routes describe how traffic coming via the Gateway maps to the Services. GatewayClass GatewayClass defines a set of Gateways that share a common configuration and behaviour. Each GatewayClass will be handled by a single controller, although controllers MAY handle more than one. GatewayClass is a cluster-scoped resource. There MUST be at least one GatewayClass defined in order to be able to have functional Gateways. A controller that implements the Gateway API does so by providing an associated GatewayClass resource that the user can reference from their Gateway(s). This is similar to IngressClass for Ingress and StorageClass for PersistentVolumes. In Ingress v1beta1, the closest analog to GatewayClass is the ingress-class annotation, and in IngressV1, the closest analog is the IngressClass object. Gateway A Gateway describes how traffic can be translated to Services within the cluster. That is, it defines a request for a way to translate traffic from somewhere that does not know about Kubernetes to somewhere that does. For example, traffic sent to a Kubernetes Services by a cloud load balancer, an in-cluster proxy or external hardware load balancer. While many use cases have client traffic originating \u201coutside\u201d the cluster, this is not a requirement. It defines a request for a specific load balancer config that implements the GatewayClass\u2019 configuration and behaviour contract. The resource MAY be created by an operator directly, or MAY be created by a controller handling a GatewayClass. As the Gateway spec captures user intent, it may not contain a complete specification for all attributes in the spec. For example, the user may omit fields such as addresses, ports, TLS settings. This allows the controller managing the GatewayClass to provide these settings for the user, resulting in a more portable spec. This behaviour will be made clear using the GatewayClass Status object. A Gateway MAY contain one or more *Route references which serve to direct traffic for a subset of traffic to a specific service. {HTTP,TCP,Foo}Route Route objects define protocol-specific rules for mapping requests from a Gateway to Kubernetes Services. HTTPRoute and TCPRoute are currently the only defined Route objects. Additional protocol-specific Route objects may be added in the future. BackendPolicy BackendPolicy provides a way to configure connections between a Gateway and a backend. For the purpose of this API, a backend is any resource that a route can forward traffic to. A common example of a backend is a Service. Configuration at this level is currently limited to TLS, but will expand in the future to support more advanced policies such as health checking. Some backend configuration may vary depending on the Route that is targeting the backend. In those cases, configuration fields will be placed on Routes and not BackendPolicy. For more information on what may be configured with this resource in the future, refer to the related GitHub issue . Combined types The combination of GatewayClass , Gateway , xRoute and Service (s) will define an implementable load-balancer. The diagram below illustrates the relationships between the different resources: Request flow A typical client/gateway API request flow for a gateway implemented using a reverse proxy is: A client makes a request to http://foo.example.com. DNS resolves the name to a Gateway address. The reverse proxy receives the request on a Listener and uses the Host header to match an HTTPRoute . Optionally, the reverse proxy can perform request header and/or path matching based on match rules of the HTTPRoute . Optionally, the reverse proxy can modify the request, i.e. add/remove headers, based on filter rules of the HTTPRoute . Lastly, the reverse proxy forwards the request to one or more objects, i.e. Service , in the cluster based on forwardTo rules of the HTTPRoute . TLS Configuration TLS is configured on Gateway listeners. Additionally, TLS certificates can be configured on route objects for certain self-service use cases. Please refer to TLS details for a deep dive on TLS. Extension points A number of extension points are provided in the API to provide flexibility in addressing the large number of use-cases that cannot be addressed by a general purpose API. Here is a summary of extension points in the API: XRouteMatch.ExtensionRef : This extension point should be used to extend the match semantics of a specific core Route. This is an experimental extension point and will be iterated on in future based on feedback. XForwardTo.BackendRef : This extension point should be used for forwarding traffic to network endpoints other than core Kubernetes Service resource. Examples include an S3 bucket, Lambda function, a file-server, etc. HTTPRouteFilter : This API type in HTTPoute provides a way to hook into the request/response lifecycle of an HTTP request. Custom Routes : If none of the above extensions points suffice for a use case, Implementers can chose to create custom Route resources for protocols that are not currently supported in the API. Whenever you are using an extension point without any prior art, please let the community know. As we learn more about usage of extension points, we would like to find the common denominators and promote the features to core/extended API conformance.","title":"API overview"},{"location":"api-overview/#api-overview","text":"This document provides an overview of Service APIs.","title":"API Overview"},{"location":"api-overview/#roles-and-personas","text":"There are 3 primary roles in Service APIs: Infrastructure Provider Cluster Operator Application Developer There could be a fourth role of Application Admin in some use cases. Please refer to the roles and personas section in the Security model for details.","title":"Roles and personas."},{"location":"api-overview/#resource-model","text":"Note: Resources will initially live in the networking.x-k8s.io API group as Custom Resource Definitions (CRDs). Unqualified resource names will implicitly be in this API group. There are three main types of objects in our resource model: GatewayClass defines a set of gateways with a common configuration and behavior. Gateway requests a point where traffic can be translated to Services within the cluster. Routes describe how traffic coming via the Gateway maps to the Services.","title":"Resource model"},{"location":"api-overview/#gatewayclass","text":"GatewayClass defines a set of Gateways that share a common configuration and behaviour. Each GatewayClass will be handled by a single controller, although controllers MAY handle more than one. GatewayClass is a cluster-scoped resource. There MUST be at least one GatewayClass defined in order to be able to have functional Gateways. A controller that implements the Gateway API does so by providing an associated GatewayClass resource that the user can reference from their Gateway(s). This is similar to IngressClass for Ingress and StorageClass for PersistentVolumes. In Ingress v1beta1, the closest analog to GatewayClass is the ingress-class annotation, and in IngressV1, the closest analog is the IngressClass object.","title":"GatewayClass"},{"location":"api-overview/#gateway","text":"A Gateway describes how traffic can be translated to Services within the cluster. That is, it defines a request for a way to translate traffic from somewhere that does not know about Kubernetes to somewhere that does. For example, traffic sent to a Kubernetes Services by a cloud load balancer, an in-cluster proxy or external hardware load balancer. While many use cases have client traffic originating \u201coutside\u201d the cluster, this is not a requirement. It defines a request for a specific load balancer config that implements the GatewayClass\u2019 configuration and behaviour contract. The resource MAY be created by an operator directly, or MAY be created by a controller handling a GatewayClass. As the Gateway spec captures user intent, it may not contain a complete specification for all attributes in the spec. For example, the user may omit fields such as addresses, ports, TLS settings. This allows the controller managing the GatewayClass to provide these settings for the user, resulting in a more portable spec. This behaviour will be made clear using the GatewayClass Status object. A Gateway MAY contain one or more *Route references which serve to direct traffic for a subset of traffic to a specific service.","title":"Gateway"},{"location":"api-overview/#httptcpfooroute","text":"Route objects define protocol-specific rules for mapping requests from a Gateway to Kubernetes Services. HTTPRoute and TCPRoute are currently the only defined Route objects. Additional protocol-specific Route objects may be added in the future.","title":"{HTTP,TCP,Foo}Route"},{"location":"api-overview/#backendpolicy","text":"BackendPolicy provides a way to configure connections between a Gateway and a backend. For the purpose of this API, a backend is any resource that a route can forward traffic to. A common example of a backend is a Service. Configuration at this level is currently limited to TLS, but will expand in the future to support more advanced policies such as health checking. Some backend configuration may vary depending on the Route that is targeting the backend. In those cases, configuration fields will be placed on Routes and not BackendPolicy. For more information on what may be configured with this resource in the future, refer to the related GitHub issue .","title":"BackendPolicy"},{"location":"api-overview/#combined-types","text":"The combination of GatewayClass , Gateway , xRoute and Service (s) will define an implementable load-balancer. The diagram below illustrates the relationships between the different resources:","title":"Combined types"},{"location":"api-overview/#request-flow","text":"A typical client/gateway API request flow for a gateway implemented using a reverse proxy is: A client makes a request to http://foo.example.com. DNS resolves the name to a Gateway address. The reverse proxy receives the request on a Listener and uses the Host header to match an HTTPRoute . Optionally, the reverse proxy can perform request header and/or path matching based on match rules of the HTTPRoute . Optionally, the reverse proxy can modify the request, i.e. add/remove headers, based on filter rules of the HTTPRoute . Lastly, the reverse proxy forwards the request to one or more objects, i.e. Service , in the cluster based on forwardTo rules of the HTTPRoute .","title":"Request flow"},{"location":"api-overview/#tls-configuration","text":"TLS is configured on Gateway listeners. Additionally, TLS certificates can be configured on route objects for certain self-service use cases. Please refer to TLS details for a deep dive on TLS.","title":"TLS Configuration"},{"location":"api-overview/#extension-points","text":"A number of extension points are provided in the API to provide flexibility in addressing the large number of use-cases that cannot be addressed by a general purpose API. Here is a summary of extension points in the API: XRouteMatch.ExtensionRef : This extension point should be used to extend the match semantics of a specific core Route. This is an experimental extension point and will be iterated on in future based on feedback. XForwardTo.BackendRef : This extension point should be used for forwarding traffic to network endpoints other than core Kubernetes Service resource. Examples include an S3 bucket, Lambda function, a file-server, etc. HTTPRouteFilter : This API type in HTTPoute provides a way to hook into the request/response lifecycle of an HTTP request. Custom Routes : If none of the above extensions points suffice for a use case, Implementers can chose to create custom Route resources for protocols that are not currently supported in the API. Whenever you are using an extension point without any prior art, please let the community know. As we learn more about usage of extension points, we would like to find the common denominators and promote the features to core/extended API conformance.","title":"Extension points"},{"location":"community/","text":"How to contribute This page contains links to all of the meeting notes, design docs and related discussions around the APIs. Feedback and Bug Reports Feedback and bug reports should be filed as Github Issues on this repo. Communications Major discussions and notifications will be sent on the SIG-NETWORK mailing list . We also have a Slack channel (sig-network-service-apis) on k8s.io for day-to-day questions, discussions. Meetings Meetings discussing the evolution of the service APIs will alternate times to accommodate participants from various time zones. This calendar includes all Service APIs meetings as well as any other SIG-Network meetings. Thursday 10:30 AM Pacific (EMEA Friendly Time) [Zoom Link] Thursday 4:30 (16:30) PM Pacific (APAC Friendly Time) Office Hours In addition to weekly meetings, we have informal weekly office hours meetings on Wednesdays. Wednesday 3:00 (15:00) PM Pacific Meeting notes Meeting agendas and notes are recorded in the meeting notes doc . All meetings are recorded and automatically uploaded to youtube: Meeting recordings . Some initial recordings of this working group were done manually and can be found in the below table: Date Future meetings Check the calendar February 27, 2019 meeting notes , recording February 20, 2019 meeting notes , recording February 13, 2019 meeting notes , recording February 6, 2019 meeting notes , recording January 30, 2019 meeting notes , recording January 23, 2019 meeting notes , recording TODO January 16, 2019 meeting notes , recording January 9, 2019 meeting notes , recording January 2, 2020 meeting notes , recording didn't work :-( look at the notes December 19, 2019 meeting notes , recording November, 2019 Kubecon 2019 San Diego: API evolution design discussion November, 2019 SIG-NETWORK: Ingress Evolution Sync May, 2019 Kubecon 2019 Barcelona: SIG-NETWORK discussion (general topics, includes V2) Presentations, Talks Date Title November, 2019 Kubecon 2019 San Diego: Evolving the Kubernetes Ingress APIs to GA and Beyond slides , video November, 2019 Kubecon 2019 San Diego: SIG-NETWORK Service/Ingress Evolution Discussion slides May, 2019 Kubecon 2019 Barcelona: Ingress V2 and Multicluster Services slides , video March, 2018 SIG-NETWORK: Ingress user survey data , slides Code of conduct Participation in the Kubernetes community is governed by the Kubernetes Code of Conduct","title":"Community"},{"location":"community/#how-to-contribute","text":"This page contains links to all of the meeting notes, design docs and related discussions around the APIs.","title":"How to contribute"},{"location":"community/#feedback-and-bug-reports","text":"Feedback and bug reports should be filed as Github Issues on this repo.","title":"Feedback and Bug Reports"},{"location":"community/#communications","text":"Major discussions and notifications will be sent on the SIG-NETWORK mailing list . We also have a Slack channel (sig-network-service-apis) on k8s.io for day-to-day questions, discussions.","title":"Communications"},{"location":"community/#meetings","text":"Meetings discussing the evolution of the service APIs will alternate times to accommodate participants from various time zones. This calendar includes all Service APIs meetings as well as any other SIG-Network meetings. Thursday 10:30 AM Pacific (EMEA Friendly Time) [Zoom Link] Thursday 4:30 (16:30) PM Pacific (APAC Friendly Time)","title":"Meetings"},{"location":"community/#office-hours","text":"In addition to weekly meetings, we have informal weekly office hours meetings on Wednesdays. Wednesday 3:00 (15:00) PM Pacific","title":"Office Hours"},{"location":"community/#meeting-notes","text":"Meeting agendas and notes are recorded in the meeting notes doc . All meetings are recorded and automatically uploaded to youtube: Meeting recordings . Some initial recordings of this working group were done manually and can be found in the below table: Date Future meetings Check the calendar February 27, 2019 meeting notes , recording February 20, 2019 meeting notes , recording February 13, 2019 meeting notes , recording February 6, 2019 meeting notes , recording January 30, 2019 meeting notes , recording January 23, 2019 meeting notes , recording TODO January 16, 2019 meeting notes , recording January 9, 2019 meeting notes , recording January 2, 2020 meeting notes , recording didn't work :-( look at the notes December 19, 2019 meeting notes , recording November, 2019 Kubecon 2019 San Diego: API evolution design discussion November, 2019 SIG-NETWORK: Ingress Evolution Sync May, 2019 Kubecon 2019 Barcelona: SIG-NETWORK discussion (general topics, includes V2)","title":"Meeting notes"},{"location":"community/#presentations-talks","text":"Date Title November, 2019 Kubecon 2019 San Diego: Evolving the Kubernetes Ingress APIs to GA and Beyond slides , video November, 2019 Kubecon 2019 San Diego: SIG-NETWORK Service/Ingress Evolution Discussion slides May, 2019 Kubecon 2019 Barcelona: Ingress V2 and Multicluster Services slides , video March, 2018 SIG-NETWORK: Ingress user survey data , slides","title":"Presentations, Talks"},{"location":"community/#code-of-conduct","text":"Participation in the Kubernetes community is governed by the Kubernetes Code of Conduct","title":"Code of conduct"},{"location":"devguide/","text":"Developing Service APIs You must have a working Go environment and then clone the repo: mkdir -p $GOPATH/src/sigs.k8s.io cd $GOPATH/src/sigs.k8s.io git clone https://github.com/kubernetes-sigs/service-apis cd service-apis This project works with Go modules; you can chose to setup your environment outside $GOPATH as well. Building, testing and deploying You will need to have Docker installed to perform the steps below. Project management We are using the Github issues and project dashboard to manage the list of TODOs for this project: Open issues Project dashboard Issues labeled good first issue and help wanted are especially good for a first contribution. We use milestones to track our progress towards releases. Looking at our current milestone can help identify our highest priority issues. Building the code The project uses make to drive the build. make will run code generators, and run static analysis against the code and generate Kubernetes CRDs. You can kick off an overall build from the top-level makefile: make Install CRDs To install service-apis CRDs into a Kubernetes cluster: make install To uninstall CRDs and associated resources: make uninstall Submitting a Pull Request Service APIs follows a similar pull request process as Kubernetes . Merging a pull request requires the following steps to be completed before the pull request will be merged automatically. Sign the CLA (prerequisite) Open a pull request Pass verification tests Get all necessary approvals from reviewers and code owners Verify Make sure you run the static analysis over the repo before submitting your changes. The Prow presubmit will not let your change merge if verification fails. make verify Documentation The site documentation is written in mkdocs format. The files are contained in docs-src/ . Generated files are in docs/ and published to Github Pages. Building the docs: make docs Live preview for editing (view on http://localhost:8000 , CTRL-C to quit): make serve Remove generated documentation files: make clean Publishing The docs are published automatically to Github pages . When making changes to the documentation, generate the new documentation and make the generated code a self-contained commit (e.g. the changes to docs/ ). This will keep the code reviews simple and clearly delineate user vs generated content.","title":"Developer guide"},{"location":"devguide/#developing-service-apis","text":"You must have a working Go environment and then clone the repo: mkdir -p $GOPATH/src/sigs.k8s.io cd $GOPATH/src/sigs.k8s.io git clone https://github.com/kubernetes-sigs/service-apis cd service-apis This project works with Go modules; you can chose to setup your environment outside $GOPATH as well.","title":"Developing Service APIs"},{"location":"devguide/#building-testing-and-deploying","text":"You will need to have Docker installed to perform the steps below.","title":"Building, testing and deploying"},{"location":"devguide/#project-management","text":"We are using the Github issues and project dashboard to manage the list of TODOs for this project: Open issues Project dashboard Issues labeled good first issue and help wanted are especially good for a first contribution. We use milestones to track our progress towards releases. Looking at our current milestone can help identify our highest priority issues.","title":"Project management"},{"location":"devguide/#building-the-code","text":"The project uses make to drive the build. make will run code generators, and run static analysis against the code and generate Kubernetes CRDs. You can kick off an overall build from the top-level makefile: make","title":"Building the code"},{"location":"devguide/#install-crds","text":"To install service-apis CRDs into a Kubernetes cluster: make install To uninstall CRDs and associated resources: make uninstall","title":"Install CRDs"},{"location":"devguide/#submitting-a-pull-request","text":"Service APIs follows a similar pull request process as Kubernetes . Merging a pull request requires the following steps to be completed before the pull request will be merged automatically. Sign the CLA (prerequisite) Open a pull request Pass verification tests Get all necessary approvals from reviewers and code owners","title":"Submitting a Pull Request"},{"location":"devguide/#verify","text":"Make sure you run the static analysis over the repo before submitting your changes. The Prow presubmit will not let your change merge if verification fails. make verify","title":"Verify"},{"location":"devguide/#documentation","text":"The site documentation is written in mkdocs format. The files are contained in docs-src/ . Generated files are in docs/ and published to Github Pages. Building the docs: make docs Live preview for editing (view on http://localhost:8000 , CTRL-C to quit): make serve Remove generated documentation files: make clean","title":"Documentation"},{"location":"devguide/#publishing","text":"The docs are published automatically to Github pages . When making changes to the documentation, generate the new documentation and make the generated code a self-contained commit (e.g. the changes to docs/ ). This will keep the code reviews simple and clearly delineate user vs generated content.","title":"Publishing"},{"location":"enhancement-requests/","text":"Enhancement Tracking and Backlog Inspired by Kubernetes enhancements , service-api's provides a process for introducing new functionality or considerable changes to the project. The enhancement process will evolve over time as the project matures. Enhancements provides the basis of a community roadmap. Enhancements may be filed by anyone, but require approval from a maintainer to accept the enhancement into the project. Quick start Create an Issue and select \"Enhancement Request\". Follow the instructions in the enhancement request template and submit the Issue. What is Considered an Enhancement? An enhancement is generally anything that: impacts how a cluster is operated including addition or removal of significant capabilities introduces changes to an api needs significant effort to implement requires documentation to utilize It is unlikely to require an enhancement if it: fixes a bug adds more testing code refactors minimal impact to a release If you're unsure the proposed work requires an enhancement, file an issue and ask. When to Create a New Enhancement Create an enhancement once you have: circulated your idea to see if there is interest. identified community members who agree to work on and maintain the enhancement. enhancements may take several releases to complete. a prototype in your own fork (optional) Why are Enhancements Tracked As the project evolves, it's important that the service-api's community understands how the enhancement affects the project. Individually, it's hard to understand how all parts of the system interact, but as a community we can work together to build the right design and approach before getting too deep into an implementation. When to Comment on an Enhancement Issue Please comment on the enhancement issue to: request a review or clarification on the process update status of the enhancement effort link to relevant issues in other repos","title":"Enhancement requests"},{"location":"enhancement-requests/#enhancement-tracking-and-backlog","text":"Inspired by Kubernetes enhancements , service-api's provides a process for introducing new functionality or considerable changes to the project. The enhancement process will evolve over time as the project matures. Enhancements provides the basis of a community roadmap. Enhancements may be filed by anyone, but require approval from a maintainer to accept the enhancement into the project.","title":"Enhancement Tracking and Backlog"},{"location":"enhancement-requests/#quick-start","text":"Create an Issue and select \"Enhancement Request\". Follow the instructions in the enhancement request template and submit the Issue.","title":"Quick start"},{"location":"enhancement-requests/#what-is-considered-an-enhancement","text":"An enhancement is generally anything that: impacts how a cluster is operated including addition or removal of significant capabilities introduces changes to an api needs significant effort to implement requires documentation to utilize It is unlikely to require an enhancement if it: fixes a bug adds more testing code refactors minimal impact to a release If you're unsure the proposed work requires an enhancement, file an issue and ask.","title":"What is Considered an Enhancement?"},{"location":"enhancement-requests/#when-to-create-a-new-enhancement","text":"Create an enhancement once you have: circulated your idea to see if there is interest. identified community members who agree to work on and maintain the enhancement. enhancements may take several releases to complete. a prototype in your own fork (optional)","title":"When to Create a New Enhancement"},{"location":"enhancement-requests/#why-are-enhancements-tracked","text":"As the project evolves, it's important that the service-api's community understands how the enhancement affects the project. Individually, it's hard to understand how all parts of the system interact, but as a community we can work together to build the right design and approach before getting too deep into an implementation.","title":"Why are Enhancements Tracked"},{"location":"enhancement-requests/#when-to-comment-on-an-enhancement-issue","text":"Please comment on the enhancement issue to: request a review or clarification on the process update status of the enhancement effort link to relevant issues in other repos","title":"When to Comment on an Enhancement Issue"},{"location":"faq/","text":"Frequently Asked Questions (FAQ) Q: How can I get involved with Service API? A: The community page keeps track of how to get involved with the project. Q: Will Service API replace the Ingress API? A: No. The Ingress API is GA since Kubernetes 1.19. There are no plans to deprecate this API and we expect most Ingress controllers to support it indefinitely. Q: What are the differences between Ingress and Service API? A: Ingress primarily targets exposing HTTP applications with a simple, declarative syntax. Service API exposes a more general API for proxying that can be used for more protocols than just HTTP, and models more infrastucture components to provide better deployment and management options for cluster operators. Q: Will there be a default controller implementation (in this repo)? A: There is no current plan to have an \"official\" or \"default\" implementation. You will see the controller code in this repo be used for testing the support libraries. Q: How can I expose custom capabilities through Service API? A: There is a lot of diversity in the networking and proxying ecosystem, and many products will have features that are not directly supported in the API. However, there are a few mechanisms available for extending the API with implementation-specific capabilities: Decorate Service API objects with implementation-specific objects. A policy or configuration object could match the Service API object either by name or by using an explicit object reference. For example, given a Gateway object with name \"inbound\", creating a AccessPolicy object that also has the name \"inbound\" could cause an implementation to attach a specified access control policy. This is an example of matching the object by name. Service API uses this decorator pattern with the BackendPolicy resource, which modifies how a Gateway should forward traffic to a backend target (commonly a Kubernetes Service ). This is an example of using explicit object references. Use implementation-specific values for string fields. In many places, the fields of Service API resources have the type \"string\". This allows an implementation to support custom values for those fields in addition to any values specified in the API. Use implementation-specific annotations. For some kinds of configuration, implementations may choose to support custom annotations on Servce API objects. This approach continues a proud tradition of extending Ingress objects. Use API-defined extension points. Some Service API objects have explicit extension points for implementations to use. Q: Where can I find Service API releases? A: Service API releases are tags of the Github repository . The Github releases page shows all the releases. Q: How should I think about the alpha release? A: The v1alpha1 release will be the first Service API release. As various projects begin implementing the API, and operators start using it, the working group will collect feedback and issues, which will guide what revisions are needed for the next release. It is possible that the next release will contain breaking changes.","title":"FAQ"},{"location":"faq/#frequently-asked-questions-faq","text":"Q: How can I get involved with Service API? A: The community page keeps track of how to get involved with the project. Q: Will Service API replace the Ingress API? A: No. The Ingress API is GA since Kubernetes 1.19. There are no plans to deprecate this API and we expect most Ingress controllers to support it indefinitely. Q: What are the differences between Ingress and Service API? A: Ingress primarily targets exposing HTTP applications with a simple, declarative syntax. Service API exposes a more general API for proxying that can be used for more protocols than just HTTP, and models more infrastucture components to provide better deployment and management options for cluster operators. Q: Will there be a default controller implementation (in this repo)? A: There is no current plan to have an \"official\" or \"default\" implementation. You will see the controller code in this repo be used for testing the support libraries. Q: How can I expose custom capabilities through Service API? A: There is a lot of diversity in the networking and proxying ecosystem, and many products will have features that are not directly supported in the API. However, there are a few mechanisms available for extending the API with implementation-specific capabilities: Decorate Service API objects with implementation-specific objects. A policy or configuration object could match the Service API object either by name or by using an explicit object reference. For example, given a Gateway object with name \"inbound\", creating a AccessPolicy object that also has the name \"inbound\" could cause an implementation to attach a specified access control policy. This is an example of matching the object by name. Service API uses this decorator pattern with the BackendPolicy resource, which modifies how a Gateway should forward traffic to a backend target (commonly a Kubernetes Service ). This is an example of using explicit object references. Use implementation-specific values for string fields. In many places, the fields of Service API resources have the type \"string\". This allows an implementation to support custom values for those fields in addition to any values specified in the API. Use implementation-specific annotations. For some kinds of configuration, implementations may choose to support custom annotations on Servce API objects. This approach continues a proud tradition of extending Ingress objects. Use API-defined extension points. Some Service API objects have explicit extension points for implementations to use. Q: Where can I find Service API releases? A: Service API releases are tags of the Github repository . The Github releases page shows all the releases. Q: How should I think about the alpha release? A: The v1alpha1 release will be the first Service API release. As various projects begin implementing the API, and operators start using it, the working group will collect feedback and issues, which will guide what revisions are needed for the next release. It is possible that the next release will contain breaking changes.","title":"Frequently Asked Questions (FAQ)"},{"location":"gateway/","text":"Gateway A Gateway is 1:1 with the life cycle of the configuration of infrastructure. When a user creates a Gateway , some load balancing infrastructure is provisioned or configured (see below for details) by the GatewayClass controller. Gateway is the resource that triggers actions in this API. Other resources in this API are configuration snippets until a Gateway has been created to link the resources together. The Gateway spec defines the following: GatewayClassName - Defines the name of a GatewayClass object used by this Gateway. Listeners - Define the hostnames, ports, protocol, termination, TLS settings and which routes should be associated to a listener. Addresses - Define the network addresses requested for this gateway. If the desired configuration specified in Gateway spec cannot be achieved, the Gateway will be in an error state with details provided by status conditions. Deployment models Depending on the GatewayClass , the creation of a Gateway could do any of the following actions: Use cloud APIs to create an LB instance. Spawn a new instance of a software LB (in this or another cluster). Add a configuration stanza to an already instantiated LB to handle the new routes. Program the SDN to implement the configuration. Something else we haven\u2019t thought of yet... The API does not specify which one of these actions will be taken. Gateway Status GatewayStatus is used to surface the status of a Gateway relative to the desired state represented in spec . GatewayStatus consists of the following: Addresses - Lists the IP addresses that have actually been bound to the Gateway. Listeners - Provide status for each unique listener port defined in spec . Conditions - Describe the current status conditions of the Gateway. Both Conditions and Listeners.conditions follow the conditions pattern used elsewhere in Kubernetes. This is a list that includes a type of condition, the status of the condition and the last time this condition changed.","title":"Gateway"},{"location":"gateway/#gateway","text":"A Gateway is 1:1 with the life cycle of the configuration of infrastructure. When a user creates a Gateway , some load balancing infrastructure is provisioned or configured (see below for details) by the GatewayClass controller. Gateway is the resource that triggers actions in this API. Other resources in this API are configuration snippets until a Gateway has been created to link the resources together. The Gateway spec defines the following: GatewayClassName - Defines the name of a GatewayClass object used by this Gateway. Listeners - Define the hostnames, ports, protocol, termination, TLS settings and which routes should be associated to a listener. Addresses - Define the network addresses requested for this gateway. If the desired configuration specified in Gateway spec cannot be achieved, the Gateway will be in an error state with details provided by status conditions.","title":"Gateway"},{"location":"gateway/#deployment-models","text":"Depending on the GatewayClass , the creation of a Gateway could do any of the following actions: Use cloud APIs to create an LB instance. Spawn a new instance of a software LB (in this or another cluster). Add a configuration stanza to an already instantiated LB to handle the new routes. Program the SDN to implement the configuration. Something else we haven\u2019t thought of yet... The API does not specify which one of these actions will be taken.","title":"Deployment models"},{"location":"gateway/#gateway-status","text":"GatewayStatus is used to surface the status of a Gateway relative to the desired state represented in spec . GatewayStatus consists of the following: Addresses - Lists the IP addresses that have actually been bound to the Gateway. Listeners - Provide status for each unique listener port defined in spec . Conditions - Describe the current status conditions of the Gateway. Both Conditions and Listeners.conditions follow the conditions pattern used elsewhere in Kubernetes. This is a list that includes a type of condition, the status of the condition and the last time this condition changed.","title":"Gateway Status"},{"location":"gatewayclass/","text":"GatewayClass GatewayClass is cluster-scoped resource defined by the infrastructure provider. This resource represents a class of Gateways that can be instantiated. Note: GatewayClass serves the same function as the networking.IngressClass resource . kind: GatewayClass metadata: name: cluster-gateway spec: controller: \"acme.io/gateway-controller\" We expect that one or more GatewayClasses will be created by the infrastructure provider for the user. It allows decoupling of which mechanism (e.g. controller) implements the Gateways from the user. For instance, an infrastructure provider may create two GatewayClasses named internet and private to reflect Gateways that define Internet-facing vs private, internal applications. kind: GatewayClass metadata: name: internet ... --- kind: GatewayClass metadata: name: private ... The user of the classes will not need to know how internet and private are implemented. Instead, the user will only need to understand the resulting properties of the class that the Gateway was created with. GatewayClass parameters Providers of the Gateway API may need to pass parameters to their controller as part of the class definition. This is done using the GatewayClass.spec.parametersRef field: # GatewayClass for Gateways that define Internet-facing applications. kind: GatewayClass metadata: name: internet spec: controller: \"acme.io/gateway-controller\" parametersRef: group: acme.io/v1alpha1 kind: Config name: internet-gateway-config --- kind: Config apiVersion: acme.io/v1alpha1 metadata: name: internet-gateway-config spec: ip-address-pool: internet-vips ... Using a Custom Resource for GatewayClass.spec.parametersRef is encouraged but implementations may resort to using a ConfigMap if needed. GatewayClass status GatewayClasses MUST be validated by the provider to ensure that the configured parameters are valid. The validity of the class will be signaled to the user via GatewayClass.status : kind: GatewayClass ... status: conditions: - type: Admitted status: False ... A new GatewayClass will start with the Admitted condition set to False . At this point the controller has not seen the configuration. Once the controller has processed the configuration, the condition will be set to True : kind: GatewayClass ... status: conditions: - type: Admitted status: True ... If there is an error in the GatewayClass.spec , the conditions will be non-empty and contain information about the error. kind: GatewayClass ... status: conditions: - type: Admitted status: False Reason: BadFooBar Message: \"foobar\" is an FooBar. GatewayClass controller selection The GatewayClass.spec.controller field determines the controller implementation responsible for managing the GatewayClass . The format of the field is opaque and specific to a particular controller. The GatewayClass selected by a given controller field depends on how various controller(s) in the cluster interpret this field. It is RECOMMENDED that controller authors/deployments make their selection unique by using a domain / path combination under their administrative control (e.g. controller managing of all controller s starting with acme.io is the owner of the acme.io domain) to avoid conflicts. Controller versioning can be done by encoding the version of a controller into the path portion. An example scheme could be (similar to container URIs): acme.io/gateway/v1 // Use version 1 acme.io/gateway/v2 // Use version 2 acme.io/gateway // Use the default version","title":"GatewayClass"},{"location":"gatewayclass/#gatewayclass","text":"GatewayClass is cluster-scoped resource defined by the infrastructure provider. This resource represents a class of Gateways that can be instantiated. Note: GatewayClass serves the same function as the networking.IngressClass resource . kind: GatewayClass metadata: name: cluster-gateway spec: controller: \"acme.io/gateway-controller\" We expect that one or more GatewayClasses will be created by the infrastructure provider for the user. It allows decoupling of which mechanism (e.g. controller) implements the Gateways from the user. For instance, an infrastructure provider may create two GatewayClasses named internet and private to reflect Gateways that define Internet-facing vs private, internal applications. kind: GatewayClass metadata: name: internet ... --- kind: GatewayClass metadata: name: private ... The user of the classes will not need to know how internet and private are implemented. Instead, the user will only need to understand the resulting properties of the class that the Gateway was created with.","title":"GatewayClass"},{"location":"gatewayclass/#gatewayclass-parameters","text":"Providers of the Gateway API may need to pass parameters to their controller as part of the class definition. This is done using the GatewayClass.spec.parametersRef field: # GatewayClass for Gateways that define Internet-facing applications. kind: GatewayClass metadata: name: internet spec: controller: \"acme.io/gateway-controller\" parametersRef: group: acme.io/v1alpha1 kind: Config name: internet-gateway-config --- kind: Config apiVersion: acme.io/v1alpha1 metadata: name: internet-gateway-config spec: ip-address-pool: internet-vips ... Using a Custom Resource for GatewayClass.spec.parametersRef is encouraged but implementations may resort to using a ConfigMap if needed.","title":"GatewayClass parameters"},{"location":"gatewayclass/#gatewayclass-status","text":"GatewayClasses MUST be validated by the provider to ensure that the configured parameters are valid. The validity of the class will be signaled to the user via GatewayClass.status : kind: GatewayClass ... status: conditions: - type: Admitted status: False ... A new GatewayClass will start with the Admitted condition set to False . At this point the controller has not seen the configuration. Once the controller has processed the configuration, the condition will be set to True : kind: GatewayClass ... status: conditions: - type: Admitted status: True ... If there is an error in the GatewayClass.spec , the conditions will be non-empty and contain information about the error. kind: GatewayClass ... status: conditions: - type: Admitted status: False Reason: BadFooBar Message: \"foobar\" is an FooBar.","title":"GatewayClass status"},{"location":"gatewayclass/#gatewayclass-controller-selection","text":"The GatewayClass.spec.controller field determines the controller implementation responsible for managing the GatewayClass . The format of the field is opaque and specific to a particular controller. The GatewayClass selected by a given controller field depends on how various controller(s) in the cluster interpret this field. It is RECOMMENDED that controller authors/deployments make their selection unique by using a domain / path combination under their administrative control (e.g. controller managing of all controller s starting with acme.io is the owner of the acme.io domain) to avoid conflicts. Controller versioning can be done by encoding the version of a controller into the path portion. An example scheme could be (similar to container URIs): acme.io/gateway/v1 // Use version 1 acme.io/gateway/v2 // Use version 2 acme.io/gateway // Use the default version","title":"GatewayClass controller selection"},{"location":"getting-started/","text":"Getting started with Services APIs Installing CRDs This project provides a collection of Custom Resource Definitions (CRDs) that can be installed into any Kubernetes (>= 1.16) cluster. To install the CRDs, please execute: kubectl kustomize \"github.com/kubernetes-sigs/service-apis/config/crd?ref=master\" \\ | kubectl apply -f - Install an implementation Multiple projects implement the APIs defined by this project. You will need to either install an implementation or verify that one is already setup for your cluster. Sample Gateway Once you have the CRDs and an implementation installed, you are ready to use Service APIs. In this example, we are installing three resources: An acme-lb GatewayClass which is being managed by a acme.io/gateway-controller controller running in the cluster. Typically, a GatewayClass is provided by the implementation and must be installed in the cluster. A Gateway which is of type acme-lb : This gateway has a single HTTP listener on port 80 which selects HTTPRoutes from all namespaces which have the label app: foo on them. Finally, we have an HTTPRoute resource which is attached to the above Gateway and has two rules: All requests with path beginning with /bar are forwarded to my-service1 Kubernetes Service. All requests with path beginning with /some/thing AND have an HTTP header magic: foo are forwarded to my-service2 Kubernetes Service. With this configuration, you now have a Gateway resource which is forwarding traffic to two Kubernetes Services based on HTTP request metadata. kind: GatewayClass apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: acme-lb spec: controller: acme.io/gateway-controller parametersRef: name: acme-lb group: acme.io kind: Parameters --- kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: my-gateway spec: gatewayClassName: acme-lb listeners: # Use GatewayClass defaults for listener definition. - protocol: HTTP port: 80 routes: kind: HTTPRoute selector: matchLabels: app: foo namespaces: from: \"Same\" --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-app-1 labels: app: foo spec: hostnames: - \"foo.com\" rules: - matches: - path: type: Prefix value: /bar forwardTo: - serviceName: my-service1 port: 8080 - matches: - headers: type: Exact values: magic: foo path: type: Prefix value: /some/thing forwardTo: - serviceName: my-service2 port: 8080 For more advanced examples, please read the other guides . Uninstalling the CRDs To uninstall the CRDs and all resources created with them, run the following command. Note that this will remove all GatewayClass and Gateway resources in your cluster. If you have been using these resources for any other purpose do not uninstall these CRDs. kubectl kustomize \"github.com/kubernetes-sigs/service-apis/config/crd?ref=master\" \\ | kubectl delete -f -","title":"Getting started"},{"location":"getting-started/#getting-started-with-services-apis","text":"","title":"Getting started with Services APIs"},{"location":"getting-started/#installing-crds","text":"This project provides a collection of Custom Resource Definitions (CRDs) that can be installed into any Kubernetes (>= 1.16) cluster. To install the CRDs, please execute: kubectl kustomize \"github.com/kubernetes-sigs/service-apis/config/crd?ref=master\" \\ | kubectl apply -f -","title":"Installing CRDs"},{"location":"getting-started/#install-an-implementation","text":"Multiple projects implement the APIs defined by this project. You will need to either install an implementation or verify that one is already setup for your cluster.","title":"Install an implementation"},{"location":"getting-started/#sample-gateway","text":"Once you have the CRDs and an implementation installed, you are ready to use Service APIs. In this example, we are installing three resources: An acme-lb GatewayClass which is being managed by a acme.io/gateway-controller controller running in the cluster. Typically, a GatewayClass is provided by the implementation and must be installed in the cluster. A Gateway which is of type acme-lb : This gateway has a single HTTP listener on port 80 which selects HTTPRoutes from all namespaces which have the label app: foo on them. Finally, we have an HTTPRoute resource which is attached to the above Gateway and has two rules: All requests with path beginning with /bar are forwarded to my-service1 Kubernetes Service. All requests with path beginning with /some/thing AND have an HTTP header magic: foo are forwarded to my-service2 Kubernetes Service. With this configuration, you now have a Gateway resource which is forwarding traffic to two Kubernetes Services based on HTTP request metadata. kind: GatewayClass apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: acme-lb spec: controller: acme.io/gateway-controller parametersRef: name: acme-lb group: acme.io kind: Parameters --- kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: my-gateway spec: gatewayClassName: acme-lb listeners: # Use GatewayClass defaults for listener definition. - protocol: HTTP port: 80 routes: kind: HTTPRoute selector: matchLabels: app: foo namespaces: from: \"Same\" --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-app-1 labels: app: foo spec: hostnames: - \"foo.com\" rules: - matches: - path: type: Prefix value: /bar forwardTo: - serviceName: my-service1 port: 8080 - matches: - headers: type: Exact values: magic: foo path: type: Prefix value: /some/thing forwardTo: - serviceName: my-service2 port: 8080 For more advanced examples, please read the other guides .","title":"Sample Gateway"},{"location":"getting-started/#uninstalling-the-crds","text":"To uninstall the CRDs and all resources created with them, run the following command. Note that this will remove all GatewayClass and Gateway resources in your cluster. If you have been using these resources for any other purpose do not uninstall these CRDs. kubectl kustomize \"github.com/kubernetes-sigs/service-apis/config/crd?ref=master\" \\ | kubectl delete -f -","title":"Uninstalling the CRDs"},{"location":"guidelines/","text":"Implementation guidelines There are some general design guidelines used throughout this API. Single resource consistency The Kubernetes API guarantees consistency only on a single resource level. There are a couple of consequences for complex resource graphs as opposed to single resources: Error checking of properties spanning multiple resource will be asynchronous and eventually consistent. Simple syntax checks will be possible at the single resource level, but cross resource dependencies will need to be handled by the controller. Controllers will need to handle broken links between resources and/or mismatched configuration. Conflicts Separation and delegation of responsibility among independent actors (e.g between cluster ops and application developers) can result in conflicts in the configuration. For example, two application teams may inadvertently submit configuration for the same HTTP path. In most cases, guidance for conflict resolution is provided along with the documentation for fields that may have a conflict. If a conflict does not have a prescribed resolution, the following guiding principles should be applied: Prefer not to break things that are working. Drop as little traffic as possible. Provide a consistent experience when conflicts occur. Make it clear which path has been chosen when a conflict has been identified. Where possible, this should be communicated by setting appropriate status conditions on relevant resources. More specific matches should be given precedence over less specific ones. The resource with the oldest creation timestamp wins. If everything else is equivalent (including creation timestamp), precedences should be given to the resource appearing first in alphabetical order (namespace/name). For example, foo/bar would be given precedence over foo/baz. Conformance As this API aims to cover a wide set of implementations and use cases, it will not be possible for all implementations to support all features at the present. However, we do expect the set of features supported to converge eventually. For a given feature, users will be guaranteed that features in the API will be portable between providers if the feature is supported. To model this in the API, we are taking a similar approach as with sig-arch work on conformance profiles. Features as described in the API spec will be divided into three major categories: CORE features will be portable and we expect that there is a reasonable roadmap for ALL implementations towards support of APIs in this category. EXTENDED features are those that are portable but not universally supported across implementations. Those implementations that support the feature will have the same behavior and semantics. It is expected that some number of EXTENDED features will eventually migrate into the CORE. EXTENDED features will be part of the API types and schema. CUSTOM features are those that are not portable and are vendor-specific. CUSTOM features will not have API types and schema except via generic extension points. Behavior and feature in the CORE and EXTENDED set will be defined and validated via behavior-driven conformance tests. CUSTOM features will not be covered by conformance tests. By including and standardizing EXTENDED features in the API spec, we expect to be able to converge on portable subsets of the API among implementations without compromising overall API support. Lack of universal support will not be a blocker towards developing portable feature sets. Standardizing on spec will make it easier to eventually graduate to CORE when support is widespread. Conformance expectations We expect there will be varying levels of conformance among the different providers in the early days of this API. Users can use the results of the conformance tests to understand areas where there may be differences in behavior from the spec.","title":"Implementation Guidelines"},{"location":"guidelines/#implementation-guidelines","text":"There are some general design guidelines used throughout this API.","title":"Implementation guidelines"},{"location":"guidelines/#single-resource-consistency","text":"The Kubernetes API guarantees consistency only on a single resource level. There are a couple of consequences for complex resource graphs as opposed to single resources: Error checking of properties spanning multiple resource will be asynchronous and eventually consistent. Simple syntax checks will be possible at the single resource level, but cross resource dependencies will need to be handled by the controller. Controllers will need to handle broken links between resources and/or mismatched configuration.","title":"Single resource consistency"},{"location":"guidelines/#conflicts","text":"Separation and delegation of responsibility among independent actors (e.g between cluster ops and application developers) can result in conflicts in the configuration. For example, two application teams may inadvertently submit configuration for the same HTTP path. In most cases, guidance for conflict resolution is provided along with the documentation for fields that may have a conflict. If a conflict does not have a prescribed resolution, the following guiding principles should be applied: Prefer not to break things that are working. Drop as little traffic as possible. Provide a consistent experience when conflicts occur. Make it clear which path has been chosen when a conflict has been identified. Where possible, this should be communicated by setting appropriate status conditions on relevant resources. More specific matches should be given precedence over less specific ones. The resource with the oldest creation timestamp wins. If everything else is equivalent (including creation timestamp), precedences should be given to the resource appearing first in alphabetical order (namespace/name). For example, foo/bar would be given precedence over foo/baz.","title":"Conflicts"},{"location":"guidelines/#conformance","text":"As this API aims to cover a wide set of implementations and use cases, it will not be possible for all implementations to support all features at the present. However, we do expect the set of features supported to converge eventually. For a given feature, users will be guaranteed that features in the API will be portable between providers if the feature is supported. To model this in the API, we are taking a similar approach as with sig-arch work on conformance profiles. Features as described in the API spec will be divided into three major categories: CORE features will be portable and we expect that there is a reasonable roadmap for ALL implementations towards support of APIs in this category. EXTENDED features are those that are portable but not universally supported across implementations. Those implementations that support the feature will have the same behavior and semantics. It is expected that some number of EXTENDED features will eventually migrate into the CORE. EXTENDED features will be part of the API types and schema. CUSTOM features are those that are not portable and are vendor-specific. CUSTOM features will not have API types and schema except via generic extension points. Behavior and feature in the CORE and EXTENDED set will be defined and validated via behavior-driven conformance tests. CUSTOM features will not be covered by conformance tests. By including and standardizing EXTENDED features in the API spec, we expect to be able to converge on portable subsets of the API among implementations without compromising overall API support. Lack of universal support will not be a blocker towards developing portable feature sets. Standardizing on spec will make it easier to eventually graduate to CORE when support is widespread.","title":"Conformance"},{"location":"guidelines/#conformance-expectations","text":"We expect there will be varying levels of conformance among the different providers in the early days of this API. Users can use the results of the conformance tests to understand areas where there may be differences in behavior from the spec.","title":"Conformance expectations"},{"location":"guides/","text":"Guides Guides demonstrate and provide examples of how to use the API. Please checkout one of the following guides: Getting started Simple Gateway Configuring TLS Routes in multiple namespaces","title":"Introduction"},{"location":"guides/#guides","text":"Guides demonstrate and provide examples of how to use the API. Please checkout one of the following guides: Getting started Simple Gateway Configuring TLS Routes in multiple namespaces","title":"Guides"},{"location":"httproute/","text":"HTTPRoute HTTPRoute is a Service APIs type for specifying routing behavior of HTTP requests from a Gateway listener to an API object, i.e. Service. Spec The specification of an HTTPRoute consists of: Gateways - Define which Gateways can use this HTTPRoute. Hostnames (optional)- Define a list of hostnames to use for matching the Host header of HTTP requests. TLS (optional)- Defines the TLS certificate to use for Hostnames defined in this Route. Rules - Define a list of rules to perform actions against matching HTTP requests. Each rule consists of matches , filters (optional), and forwardTo (optional) fields. The following illustrates an HTTPRoute that sends all traffic to one Service: Gateways Gateways define which Gateways can use the HTTPRoute. If unspecified, gateways defaults to allow: SameNamespace which allows all Gateways in the HTTPRoute's namespace. The following example allows Gateways from namespace \"httproute-ns-example\": kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: httproute-example namespace: httproute-ns-example spec: gateways: allow: SameNamespace Possible values for allow are: All : Gateways in any namespace can use this route. FromList : Only Gateways specified in gatewayRefs may use this route. SameNamespace (default): Only Gateways in the same namespace may use this route. If allow results in preventing the selection of an HTTPRoute by a Gateway, an \u201cAdmitted: false\u201d condition must be set on the Gateway for this Route. Hostnames Hostnames define a list of hostnames to match against the Host header of the HTTP request. When a match occurs, the HTTPRoute is selected to perform request routing based on rules and filters (optional). A hostname is the fully qualified domain name of a network host, as defined by RFC 3986 . Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: IPs are not allowed. The : delimiter is not respected because ports are not allowed. Incoming requests are matched against hostnames before the HTTPRoute rules are evaluated. If no hostname is specified, traffic is routed based on HTTPRoute rules and filters (optional). The following example defines hostname \"my.example.com\" and allows Gateways from the same namespace as HTTPRoute \"httproute-example\": kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: httproute-example spec: gateways: allow: SameNamespace hostnames: - my.example.com TLS TLS defines the TLS certificate used for hostnames defined in this HTTPRoute. This configuration only takes effect if certificate: Allow is set for routeOverride in the associated Gateway. For example: kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: tls-basic spec: gatewayClassName: acme-lb listeners: - protocol: HTTPS port: 443 hostname: foo.example.com tls: certificateRef: kind: Secret group: core name: foo-example-com-cert routeOverride: certificate: Deny routes: kind: HTTPRoute - protocol: HTTPS port: 443 hostname: bar.example.com tls: certificateRef: kind: Secret group: core name: bar-example-com-cert routeOverride: certificate: Deny routes: kind: HTTPRoute CertificateRef refers to a Kubernetes object that contains a TLS certificate and private key. This certificate MUST be used for TLS handshakes for the domain this tls is associated with. If an entry in this list omits or specifies the empty string for both the group and kind , the resource defaults to \u201csecrets\u201d. Notes: HTTPRoute selection takes place after the TLS Handshake (ClientHello). Due to this, a TLS certificate in an HTTPRoute will take precedence even if the request has the potential to match multiple HTTPRoutes (in case multiple HTTPRoutes share the same hostname). Collisions can happen if multiple HTTPRoutes define a TLS certificate for the same hostname. In such case, the certificate in the oldest HTTPRoute is selected. Rules Rules define semantics for matching an HTTP request based on conditions, optionally executing additional processing steps, and optionally forwarding the request to an API object. Matches Matches define conditions used for matching an HTTP request. Each match is independent, i.e. this rule will be matched if any single match is satisfied. Take the following matches configuration as an example: kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 ... matches: - path: value: \"/foo\" headers: values: version: \"2\" - path: value: \"/v2/foo\" For a request to match against this rule, it must satisfy EITHER of the following conditions: A path prefixed with /foo AND contains the header \"version: 2\" A path prefix of /v2/foo If no matches are specified, the default is a prefix path match on \u201c/\u201d, which has the effect of matching every HTTP request. Filters (optional) Filters define processing steps that must be completed during the request or response lifecycle. Filters act as an extension point to express additional processing that may be performed in Gateway implementations. Some examples include request or response modification, implementing authentication strategies, rate-limiting, and traffic shaping. The following example adds header \"my-header: foo\" to HTTP requests with Host header \"my.filter.com\". kind: GatewayClass apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: filter-lb spec: controller: acme.io/gateway-controller parametersRef: name: acme-lb group: acme.io kind: Parameters --- kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: my-filter-gateway spec: gatewayClassName: filter-lb listeners: - protocol: HTTP port: 80 routes: kind: HTTPRoute selector: matchLabels: app: filter namespaces: from: \"All\" --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-filter-1 labels: app: filter spec: hostnames: - my.filter.com rules: - matches: - path: type: Prefix value: / filters: - type: RequestHeaderModifier requestHeaderModifier: add: my-header: foo forwardTo: - serviceName: my-filter-svc1 weight: 1 port: 80 API conformance is defined based on the filter type. The effects of ordering multiple behaviors is currently unspecified. This may change in the future based on feedback during the alpha stage. Conformance levels are defined by the filter type: All \"core\" filters MUST be supported by implementations. Implementers are encouraged to support \"extended\" filters. \"Custom\" filters have no API guarantees across implementations. Specifying a core filter multiple times has unspecified or custom conformance. ForwardTo (optional) ForwardTo defines API objects where matching requests should be sent. If unspecified, the rule performs no forwarding. If unspecified and no filters are specified that would result in a response being sent, a 503 error code is returned. The following example forwards HTTP requests for prefiex /bar to service \"my-service1\" on port 8080 and HTTP requests for prefex /some/thing with header magic: foo to service \"my-service2\" on port 8080 : kind: GatewayClass apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: acme-lb spec: controller: acme.io/gateway-controller parametersRef: name: acme-lb group: acme.io kind: Parameters --- kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: my-gateway spec: gatewayClassName: acme-lb listeners: # Use GatewayClass defaults for listener definition. - protocol: HTTP port: 80 routes: kind: HTTPRoute selector: matchLabels: app: foo namespaces: from: \"Same\" --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-app-1 labels: app: foo spec: hostnames: - \"foo.com\" rules: - matches: - path: type: Prefix value: /bar forwardTo: - serviceName: my-service1 port: 8080 - matches: - headers: type: Exact values: magic: foo path: type: Prefix value: /some/thing forwardTo: - serviceName: my-service2 port: 8080 Note: Forwarding to a custom resource instead of a service can be accomplished by specifying backendRef instead of serviceName . A backendRef follows the standard Kubernetes group , kind and name schema. The following example uses the weight field to forward HTTP requests for prefix /bar equally across service \"my-trafficsplit-svc1\" and service \"my-trafficsplit-svc2\", i.e. traffic splitting: kind: GatewayClass apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: trafficsplit-lb spec: controller: acme.io/gateway-controller parametersRef: name: acme-lb group: acme.io kind: Parameters --- kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: my-trafficsplit-gateway spec: gatewayClassName: trafficsplit-lb listeners: # Use GatewayClass defaults for listener definition. - protocol: HTTP port: 80 routes: kind: HTTPRoute selector: matchLabels: app: split namespaces: from: \"Selector\" selector: {} --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-trafficsplit-1 labels: app: split spec: hostnames: - \"my.trafficsplit.com\" rules: - matches: - path: type: Exact value: /bar forwardTo: - serviceName: my-trafficsplit-svc1 port: 8080 weight: 50 - serviceName: my-trafficsplit-svc2 port: 8080 weight: 50 Reference the forwardTo API documentation for additional details of weight and other fields. Status Status defines the observed state of HTTPRoute. RouteStatus RouteStatus defines the observed state that is required across all route types. Gateways Gateways define a list of the Gateways that are associated with the HTTPRoute, and the status of the HTTPRoute with respect to each of these Gateways. When a Gateway selects this HTTPRoute, the controller that manages the Gateway should add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route is modified. The following example indicates HTTPRoute \"http-example\" has been admitted by Gateway \"gw-example\" in namespace \"gw-example-ns\": kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-example ... status: gateways: - gatewayRef: name: gw-example namespace: gw-example-ns conditions: - type: Admitted status: \"True\" A maximum of 100 Gateways can be represented in this list. If this list is full, there may be additional Gateways using this Route that are not included in the list.","title":"HTTPRoute"},{"location":"httproute/#httproute","text":"HTTPRoute is a Service APIs type for specifying routing behavior of HTTP requests from a Gateway listener to an API object, i.e. Service.","title":"HTTPRoute"},{"location":"httproute/#spec","text":"The specification of an HTTPRoute consists of: Gateways - Define which Gateways can use this HTTPRoute. Hostnames (optional)- Define a list of hostnames to use for matching the Host header of HTTP requests. TLS (optional)- Defines the TLS certificate to use for Hostnames defined in this Route. Rules - Define a list of rules to perform actions against matching HTTP requests. Each rule consists of matches , filters (optional), and forwardTo (optional) fields. The following illustrates an HTTPRoute that sends all traffic to one Service:","title":"Spec"},{"location":"httproute/#gateways","text":"Gateways define which Gateways can use the HTTPRoute. If unspecified, gateways defaults to allow: SameNamespace which allows all Gateways in the HTTPRoute's namespace. The following example allows Gateways from namespace \"httproute-ns-example\": kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: httproute-example namespace: httproute-ns-example spec: gateways: allow: SameNamespace Possible values for allow are: All : Gateways in any namespace can use this route. FromList : Only Gateways specified in gatewayRefs may use this route. SameNamespace (default): Only Gateways in the same namespace may use this route. If allow results in preventing the selection of an HTTPRoute by a Gateway, an \u201cAdmitted: false\u201d condition must be set on the Gateway for this Route.","title":"Gateways"},{"location":"httproute/#hostnames","text":"Hostnames define a list of hostnames to match against the Host header of the HTTP request. When a match occurs, the HTTPRoute is selected to perform request routing based on rules and filters (optional). A hostname is the fully qualified domain name of a network host, as defined by RFC 3986 . Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: IPs are not allowed. The : delimiter is not respected because ports are not allowed. Incoming requests are matched against hostnames before the HTTPRoute rules are evaluated. If no hostname is specified, traffic is routed based on HTTPRoute rules and filters (optional). The following example defines hostname \"my.example.com\" and allows Gateways from the same namespace as HTTPRoute \"httproute-example\": kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: httproute-example spec: gateways: allow: SameNamespace hostnames: - my.example.com","title":"Hostnames"},{"location":"httproute/#tls","text":"TLS defines the TLS certificate used for hostnames defined in this HTTPRoute. This configuration only takes effect if certificate: Allow is set for routeOverride in the associated Gateway. For example: kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: tls-basic spec: gatewayClassName: acme-lb listeners: - protocol: HTTPS port: 443 hostname: foo.example.com tls: certificateRef: kind: Secret group: core name: foo-example-com-cert routeOverride: certificate: Deny routes: kind: HTTPRoute - protocol: HTTPS port: 443 hostname: bar.example.com tls: certificateRef: kind: Secret group: core name: bar-example-com-cert routeOverride: certificate: Deny routes: kind: HTTPRoute CertificateRef refers to a Kubernetes object that contains a TLS certificate and private key. This certificate MUST be used for TLS handshakes for the domain this tls is associated with. If an entry in this list omits or specifies the empty string for both the group and kind , the resource defaults to \u201csecrets\u201d. Notes: HTTPRoute selection takes place after the TLS Handshake (ClientHello). Due to this, a TLS certificate in an HTTPRoute will take precedence even if the request has the potential to match multiple HTTPRoutes (in case multiple HTTPRoutes share the same hostname). Collisions can happen if multiple HTTPRoutes define a TLS certificate for the same hostname. In such case, the certificate in the oldest HTTPRoute is selected.","title":"TLS"},{"location":"httproute/#rules","text":"Rules define semantics for matching an HTTP request based on conditions, optionally executing additional processing steps, and optionally forwarding the request to an API object.","title":"Rules"},{"location":"httproute/#matches","text":"Matches define conditions used for matching an HTTP request. Each match is independent, i.e. this rule will be matched if any single match is satisfied. Take the following matches configuration as an example: kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 ... matches: - path: value: \"/foo\" headers: values: version: \"2\" - path: value: \"/v2/foo\" For a request to match against this rule, it must satisfy EITHER of the following conditions: A path prefixed with /foo AND contains the header \"version: 2\" A path prefix of /v2/foo If no matches are specified, the default is a prefix path match on \u201c/\u201d, which has the effect of matching every HTTP request.","title":"Matches"},{"location":"httproute/#filters-optional","text":"Filters define processing steps that must be completed during the request or response lifecycle. Filters act as an extension point to express additional processing that may be performed in Gateway implementations. Some examples include request or response modification, implementing authentication strategies, rate-limiting, and traffic shaping. The following example adds header \"my-header: foo\" to HTTP requests with Host header \"my.filter.com\". kind: GatewayClass apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: filter-lb spec: controller: acme.io/gateway-controller parametersRef: name: acme-lb group: acme.io kind: Parameters --- kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: my-filter-gateway spec: gatewayClassName: filter-lb listeners: - protocol: HTTP port: 80 routes: kind: HTTPRoute selector: matchLabels: app: filter namespaces: from: \"All\" --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-filter-1 labels: app: filter spec: hostnames: - my.filter.com rules: - matches: - path: type: Prefix value: / filters: - type: RequestHeaderModifier requestHeaderModifier: add: my-header: foo forwardTo: - serviceName: my-filter-svc1 weight: 1 port: 80 API conformance is defined based on the filter type. The effects of ordering multiple behaviors is currently unspecified. This may change in the future based on feedback during the alpha stage. Conformance levels are defined by the filter type: All \"core\" filters MUST be supported by implementations. Implementers are encouraged to support \"extended\" filters. \"Custom\" filters have no API guarantees across implementations. Specifying a core filter multiple times has unspecified or custom conformance.","title":"Filters (optional)"},{"location":"httproute/#forwardto-optional","text":"ForwardTo defines API objects where matching requests should be sent. If unspecified, the rule performs no forwarding. If unspecified and no filters are specified that would result in a response being sent, a 503 error code is returned. The following example forwards HTTP requests for prefiex /bar to service \"my-service1\" on port 8080 and HTTP requests for prefex /some/thing with header magic: foo to service \"my-service2\" on port 8080 : kind: GatewayClass apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: acme-lb spec: controller: acme.io/gateway-controller parametersRef: name: acme-lb group: acme.io kind: Parameters --- kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: my-gateway spec: gatewayClassName: acme-lb listeners: # Use GatewayClass defaults for listener definition. - protocol: HTTP port: 80 routes: kind: HTTPRoute selector: matchLabels: app: foo namespaces: from: \"Same\" --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-app-1 labels: app: foo spec: hostnames: - \"foo.com\" rules: - matches: - path: type: Prefix value: /bar forwardTo: - serviceName: my-service1 port: 8080 - matches: - headers: type: Exact values: magic: foo path: type: Prefix value: /some/thing forwardTo: - serviceName: my-service2 port: 8080 Note: Forwarding to a custom resource instead of a service can be accomplished by specifying backendRef instead of serviceName . A backendRef follows the standard Kubernetes group , kind and name schema. The following example uses the weight field to forward HTTP requests for prefix /bar equally across service \"my-trafficsplit-svc1\" and service \"my-trafficsplit-svc2\", i.e. traffic splitting: kind: GatewayClass apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: trafficsplit-lb spec: controller: acme.io/gateway-controller parametersRef: name: acme-lb group: acme.io kind: Parameters --- kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: my-trafficsplit-gateway spec: gatewayClassName: trafficsplit-lb listeners: # Use GatewayClass defaults for listener definition. - protocol: HTTP port: 80 routes: kind: HTTPRoute selector: matchLabels: app: split namespaces: from: \"Selector\" selector: {} --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-trafficsplit-1 labels: app: split spec: hostnames: - \"my.trafficsplit.com\" rules: - matches: - path: type: Exact value: /bar forwardTo: - serviceName: my-trafficsplit-svc1 port: 8080 weight: 50 - serviceName: my-trafficsplit-svc2 port: 8080 weight: 50 Reference the forwardTo API documentation for additional details of weight and other fields.","title":"ForwardTo (optional)"},{"location":"httproute/#status","text":"Status defines the observed state of HTTPRoute.","title":"Status"},{"location":"httproute/#routestatus","text":"RouteStatus defines the observed state that is required across all route types.","title":"RouteStatus"},{"location":"httproute/#gateways_1","text":"Gateways define a list of the Gateways that are associated with the HTTPRoute, and the status of the HTTPRoute with respect to each of these Gateways. When a Gateway selects this HTTPRoute, the controller that manages the Gateway should add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route is modified. The following example indicates HTTPRoute \"http-example\" has been admitted by Gateway \"gw-example\" in namespace \"gw-example-ns\": kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-example ... status: gateways: - gatewayRef: name: gw-example namespace: gw-example-ns conditions: - type: Admitted status: \"True\" A maximum of 100 Gateways can be represented in this list. If this list is full, there may be additional Gateways using this Route that are not included in the list.","title":"Gateways"},{"location":"multiple-ns/","text":"Routes in multiple namespaces With the Service APIs, a single Gateway can target routes across multiple namespaces. This guide assumes that you have installed Service APIs CRDs and a conformant controller. In the following example: acme-lb GatewayClass: The GatewayClass responsible for satisfying Gateway and Route resources. multi-ns-gateaway Gateway: The Gateway is configured with a single listener on port 80 which selects routes that have the label product: baz in any namespace. Notice how the routes.namespaces.from field in the listener is set to All . service-apis-example-ns1 and service-apis-example-ns2 Namespaces: These are the namespaces in which route resources are instantiated. http-app-1 and http-app-2 HTTPRoutes: These are two resources that are installed in separate namespaces. These routes will be bound to Gateway multi-ns-gateway for the following reasons: Both have the product: baz label on them. http-app-1 HTTPRoute has spec.gateways.allow set to All . The route owner has opted to allow all Gateways in the cluster to bind to this Route. http-app-2 HTTPRoute has spec.gateways.allow set to FromList and contains a reference to the multi-ns-gateway in default namespace. This means that only the specified Gateway resource can bind to this route. Additional Gateways may be added to this list to allow them to bind to this route. kind: GatewayClass apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: acme-lb spec: controller: acme.io/gateway-controller parametersRef: name: acme-lb group: acme.io kind: Parameters --- kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: multi-ns-gateway namespace: default spec: gatewayClassName: acme-lb listeners: # Use GatewayClass defaults for listener definition. - protocol: HTTP port: 80 routes: kind: HTTPRoute selector: matchLabels: product: baz namespaces: from: \"All\" --- kind: Namespace apiVersion: v1 metadata: name: service-apis-example-ns1 --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-app-1 namespace: service-apis-example-ns1 labels: product: baz spec: gateways: allow: All hostnames: - \"foo.com\" rules: - matches: - path: type: Prefix value: /bar forwardTo: - serviceName: my-foo-service1 port: 8080 - matches: - headers: type: Exact values: magic: foo path: type: Prefix value: /some/thing forwardTo: - serviceName: my-foo-service2 port: 8080 --- kind: Namespace apiVersion: v1 metadata: name: service-apis-example-ns2 --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-app-2 namespace: service-apis-example-ns2 labels: product: baz spec: gateways: allow: FromList gatewayRefs: - name: multi-ns-gateway namespace: default hostnames: - \"bar.com\" rules: - matches: - path: type: Prefix value: / forwardTo: - serviceName: my-bar-service1 port: 8080 Please note that this guide illustrates this feature for HTTPRoute resource only as an example. The same can be accomplished with other route types as well.","title":"Multiple namespaces and routes"},{"location":"multiple-ns/#routes-in-multiple-namespaces","text":"With the Service APIs, a single Gateway can target routes across multiple namespaces. This guide assumes that you have installed Service APIs CRDs and a conformant controller. In the following example: acme-lb GatewayClass: The GatewayClass responsible for satisfying Gateway and Route resources. multi-ns-gateaway Gateway: The Gateway is configured with a single listener on port 80 which selects routes that have the label product: baz in any namespace. Notice how the routes.namespaces.from field in the listener is set to All . service-apis-example-ns1 and service-apis-example-ns2 Namespaces: These are the namespaces in which route resources are instantiated. http-app-1 and http-app-2 HTTPRoutes: These are two resources that are installed in separate namespaces. These routes will be bound to Gateway multi-ns-gateway for the following reasons: Both have the product: baz label on them. http-app-1 HTTPRoute has spec.gateways.allow set to All . The route owner has opted to allow all Gateways in the cluster to bind to this Route. http-app-2 HTTPRoute has spec.gateways.allow set to FromList and contains a reference to the multi-ns-gateway in default namespace. This means that only the specified Gateway resource can bind to this route. Additional Gateways may be added to this list to allow them to bind to this route. kind: GatewayClass apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: acme-lb spec: controller: acme.io/gateway-controller parametersRef: name: acme-lb group: acme.io kind: Parameters --- kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: multi-ns-gateway namespace: default spec: gatewayClassName: acme-lb listeners: # Use GatewayClass defaults for listener definition. - protocol: HTTP port: 80 routes: kind: HTTPRoute selector: matchLabels: product: baz namespaces: from: \"All\" --- kind: Namespace apiVersion: v1 metadata: name: service-apis-example-ns1 --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-app-1 namespace: service-apis-example-ns1 labels: product: baz spec: gateways: allow: All hostnames: - \"foo.com\" rules: - matches: - path: type: Prefix value: /bar forwardTo: - serviceName: my-foo-service1 port: 8080 - matches: - headers: type: Exact values: magic: foo path: type: Prefix value: /some/thing forwardTo: - serviceName: my-foo-service2 port: 8080 --- kind: Namespace apiVersion: v1 metadata: name: service-apis-example-ns2 --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-app-2 namespace: service-apis-example-ns2 labels: product: baz spec: gateways: allow: FromList gatewayRefs: - name: multi-ns-gateway namespace: default hostnames: - \"bar.com\" rules: - matches: - path: type: Prefix value: / forwardTo: - serviceName: my-bar-service1 port: 8080 Please note that this guide illustrates this feature for HTTPRoute resource only as an example. The same can be accomplished with other route types as well.","title":"Routes in multiple namespaces"},{"location":"releases/","text":"Releases Although Service APIs are an official Kubernetes project, and represent official APIs, these APIs will not be installed by default on Kubernetes clusters at this time. This project will use Custom Resource Definitions (CRDs) to represent the new API types that Service APIs include. Similar to other Kubernetes APIs, these will go through a formal Kubernetes Enhancement Proposal (KEP) review. Unlike other Kubernetes APIs, Service API releases will be independent from Kubernetes releases initially. Service API releases will include four components: Custom Resource Definitions to define the API. Go client libraries. Validation webhooks to implement cross field validations. Conversion webhooks to convert resources between API versions. Versioning Versioning will be completely separate from the Kubernetes release process, but similar methodology will be used. Service API versions will use the same version level requirements as other Kubernetes features . Installation This project will be responsible for providing straightforward and reliable ways to install releases of Service APIs. Other Official Custom Resources This is a relatively new concept, and there is only one previous example of official custom resources being used: VolumeSnapshots . Although VolumeSnapshot CRDs can be installed directly by CSI drivers that support them, Service APIs must support multiple controllers per cluster, so the CRDs will live in and be installed from this repo.","title":"Releases"},{"location":"releases/#releases","text":"Although Service APIs are an official Kubernetes project, and represent official APIs, these APIs will not be installed by default on Kubernetes clusters at this time. This project will use Custom Resource Definitions (CRDs) to represent the new API types that Service APIs include. Similar to other Kubernetes APIs, these will go through a formal Kubernetes Enhancement Proposal (KEP) review. Unlike other Kubernetes APIs, Service API releases will be independent from Kubernetes releases initially. Service API releases will include four components: Custom Resource Definitions to define the API. Go client libraries. Validation webhooks to implement cross field validations. Conversion webhooks to convert resources between API versions.","title":"Releases"},{"location":"releases/#versioning","text":"Versioning will be completely separate from the Kubernetes release process, but similar methodology will be used. Service API versions will use the same version level requirements as other Kubernetes features .","title":"Versioning"},{"location":"releases/#installation","text":"This project will be responsible for providing straightforward and reliable ways to install releases of Service APIs.","title":"Installation"},{"location":"releases/#other-official-custom-resources","text":"This is a relatively new concept, and there is only one previous example of official custom resources being used: VolumeSnapshots . Although VolumeSnapshot CRDs can be installed directly by CSI drivers that support them, Service APIs must support multiple controllers per cluster, so the CRDs will live in and be installed from this repo.","title":"Other Official Custom Resources"},{"location":"security-model/","text":"Security Model Introduction The Service APIs have been designed to enable granular authorization for each role in a typical organization. Resources The Service APIs have 3 primary API resources: GatewayClass defines a set of gateways with a common configuration and behavior. Gateway requests a point where traffic can be translated to Services within the cluster. Routes describe how traffic coming via the Gateway maps to the Services. Additional Configuration There are two additional pieces of configuration that are important in this security model: Which namespaces can contain Gateways of the specified GatewayClass. Which namespaces Routes can be targeted in by Gateways of the specified GatewayClass. Roles and personas In the original design of Kubernetes, Ingress and Service resources were based on a self-service model of usage; developers who create Services and Ingresses control all aspects of defining and exposing their applications to their users. We have found that the self-service model does not fully capture some of the more complex deployment and team structures that our users are seeing. The Service APIs are designed to target the following personas: Infrastructure provider : The infrastructure provider (infra) is responsible for the overall environment that the cluster(s) are operating in. Examples include: the cloud provider (AWS, Azure, GCP, ...), the PaaS provider in a company. Cluster operator : The cluster operator (ops) is responsible for administration of entire clusters. They manage policies, network access, application permissions. Application developer : The application developer (dev) is responsible for defining their application configuration (e.g. timeouts, request matching/filter) and Service composition (e.g. path routing to backends). Although these roles can cover a wide variety of use cases, some organizations may be structured slightly differently. Many organizations may also have a fourth role that sits between \"cluster operator\" and \"application developer\": Application admin : The application admin has administrative access to some namespaces within a cluster, but not the cluster as a whole. We expect that each persona will map approximately to a Role in the Kubernetes Role-Based Authentication (RBAC) system and will define resource model responsibility and separation. Depending on the environment, multiple roles can map to the same user. For example, giving the user all the above roles replicates the self-service model. The Security Model There are two primary components to the Service APIs security model: RBAC and namespace restrictions. RBAC RBAC (role-based access control) is the standard used for Kubernetes authorization. This allows users to configure who can perform actions on resources in specific scopes. RBAC can be used to enable each of the roles defined above. In most cases, it will be desirable to have all resources be readable by most roles, so instead we'll focus on write access for this model. Write Permissions for Simple 3 Tier Model GatewayClass Gateway Route Infrastructure Provider Yes Yes Yes Cluster Operators No Yes Yes Application Developers No No Yes Write Permissions for Advanced 4 Tier Model GatewayClass Gateway Route Infrastructure Provider Yes Yes Yes Cluster Operators Sometimes Yes Yes Application Admins No In Specified Namespaces In Specified Namespaces Application Developers No No In Specified Namespaces Limiting Namespaces Where a GatewayClass Can Be Used Some infrastructure providers or cluster operators may wish to limit the namespaces where a GatewayClass can be used. At this point, we do not have a solution for this built into the API. We continue to explore options to improve support for this. Until then, we recommend using a policy agent such as Open Policy Agent and Gatekeeper to enforce these kinds of policies. For reference, we've created an example of configuration that could be used for this. Route Namespaces Service APIs allow Gateways to select Routes across multiple Namespaces. Although this can be remarkably powerful, this capability needs to be used carefully. Gateways include a RouteNamespaces field that allows selecting multiple namespaces with a label selector. By default, this is limited to Routes in the same namespace as the Gateway. Additionally, Routes include a Gateways field that allows them to restrict which Gateways use them. If the Gateways field is not specified (i.e. its empty), then the Route will default to allowing selection by Gateways in the same namespace. Controller Requirements To be considered conformant with the Service APIs spec, controllers need to: Populate status fields on Gateways and Resources to indicate if they are compatible with the corresponding GatewayClass configuration. Ensure that all Routes added to a Gateway: Have been selected by the Gateway. Have a Gateways field that allows the Gateway use of the route. Alternative Approaches Considered New API Resources We considered introducing new API resources to cover these use cases. These resources might be look something like: ClusterGateway : A ClusterGateway could reference routes in any namespace. ClusterRoute : A ClusterRoute could be referenced by any Gateway or ClusterGateway. Benefits Easy to model with RBAC. API validation tied directly to each resource. Downsides New resources to deal with - more informers, clients, documentation, etc. Harder to expand with additional options in the future - may just end up with tons of API resources to cover all use cases. Boolean Multi Namespace Route Indicator on GatewayClass Instead of having the routeNamespaceSelector field on GatewayClass, we would use a boolean multiNamespaceRoutes field to indicate if Gateways of this class can target routes in multiple namespaces. This would default to false. A false value here would indicate that routes could only be targeted in the current namespace. Benefits Helpful for multi-tenant use cases with many isolated Gateways. Simple configuration with an easy to understand default value. Downsides GatewayClass admins are unable to partially limit namespaces that can be targeted by Gateways. Admins would have to choose between allowing access to Routes in all namespaces or only the local one. Validating Webhook A validating webhook could potentially handle some of the cross-resource validation necessary for this security model and provide more immediate feedback to end users. Benefits Immediate validation feedback. More validation logic stays in core Service APIs codebase. Downsides Imperfect solution for cross-resource validation. For example, a change to a GatewayClass could affect the validity of corresponding Gateway. Additional complexity involved in installing Service APIs in a cluster.","title":"Security Model"},{"location":"security-model/#security-model","text":"","title":"Security Model"},{"location":"security-model/#introduction","text":"The Service APIs have been designed to enable granular authorization for each role in a typical organization.","title":"Introduction"},{"location":"security-model/#resources","text":"The Service APIs have 3 primary API resources: GatewayClass defines a set of gateways with a common configuration and behavior. Gateway requests a point where traffic can be translated to Services within the cluster. Routes describe how traffic coming via the Gateway maps to the Services.","title":"Resources"},{"location":"security-model/#additional-configuration","text":"There are two additional pieces of configuration that are important in this security model: Which namespaces can contain Gateways of the specified GatewayClass. Which namespaces Routes can be targeted in by Gateways of the specified GatewayClass.","title":"Additional Configuration"},{"location":"security-model/#roles-and-personas","text":"In the original design of Kubernetes, Ingress and Service resources were based on a self-service model of usage; developers who create Services and Ingresses control all aspects of defining and exposing their applications to their users. We have found that the self-service model does not fully capture some of the more complex deployment and team structures that our users are seeing. The Service APIs are designed to target the following personas: Infrastructure provider : The infrastructure provider (infra) is responsible for the overall environment that the cluster(s) are operating in. Examples include: the cloud provider (AWS, Azure, GCP, ...), the PaaS provider in a company. Cluster operator : The cluster operator (ops) is responsible for administration of entire clusters. They manage policies, network access, application permissions. Application developer : The application developer (dev) is responsible for defining their application configuration (e.g. timeouts, request matching/filter) and Service composition (e.g. path routing to backends). Although these roles can cover a wide variety of use cases, some organizations may be structured slightly differently. Many organizations may also have a fourth role that sits between \"cluster operator\" and \"application developer\": Application admin : The application admin has administrative access to some namespaces within a cluster, but not the cluster as a whole. We expect that each persona will map approximately to a Role in the Kubernetes Role-Based Authentication (RBAC) system and will define resource model responsibility and separation. Depending on the environment, multiple roles can map to the same user. For example, giving the user all the above roles replicates the self-service model.","title":"Roles and personas"},{"location":"security-model/#the-security-model","text":"There are two primary components to the Service APIs security model: RBAC and namespace restrictions.","title":"The Security Model"},{"location":"security-model/#rbac","text":"RBAC (role-based access control) is the standard used for Kubernetes authorization. This allows users to configure who can perform actions on resources in specific scopes. RBAC can be used to enable each of the roles defined above. In most cases, it will be desirable to have all resources be readable by most roles, so instead we'll focus on write access for this model.","title":"RBAC"},{"location":"security-model/#write-permissions-for-simple-3-tier-model","text":"GatewayClass Gateway Route Infrastructure Provider Yes Yes Yes Cluster Operators No Yes Yes Application Developers No No Yes","title":"Write Permissions for Simple 3 Tier Model"},{"location":"security-model/#write-permissions-for-advanced-4-tier-model","text":"GatewayClass Gateway Route Infrastructure Provider Yes Yes Yes Cluster Operators Sometimes Yes Yes Application Admins No In Specified Namespaces In Specified Namespaces Application Developers No No In Specified Namespaces","title":"Write Permissions for Advanced 4 Tier Model"},{"location":"security-model/#limiting-namespaces-where-a-gatewayclass-can-be-used","text":"Some infrastructure providers or cluster operators may wish to limit the namespaces where a GatewayClass can be used. At this point, we do not have a solution for this built into the API. We continue to explore options to improve support for this. Until then, we recommend using a policy agent such as Open Policy Agent and Gatekeeper to enforce these kinds of policies. For reference, we've created an example of configuration that could be used for this.","title":"Limiting Namespaces Where a GatewayClass Can Be Used"},{"location":"security-model/#route-namespaces","text":"Service APIs allow Gateways to select Routes across multiple Namespaces. Although this can be remarkably powerful, this capability needs to be used carefully. Gateways include a RouteNamespaces field that allows selecting multiple namespaces with a label selector. By default, this is limited to Routes in the same namespace as the Gateway. Additionally, Routes include a Gateways field that allows them to restrict which Gateways use them. If the Gateways field is not specified (i.e. its empty), then the Route will default to allowing selection by Gateways in the same namespace.","title":"Route Namespaces"},{"location":"security-model/#controller-requirements","text":"To be considered conformant with the Service APIs spec, controllers need to: Populate status fields on Gateways and Resources to indicate if they are compatible with the corresponding GatewayClass configuration. Ensure that all Routes added to a Gateway: Have been selected by the Gateway. Have a Gateways field that allows the Gateway use of the route.","title":"Controller Requirements"},{"location":"security-model/#alternative-approaches-considered","text":"","title":"Alternative Approaches Considered"},{"location":"security-model/#new-api-resources","text":"We considered introducing new API resources to cover these use cases. These resources might be look something like: ClusterGateway : A ClusterGateway could reference routes in any namespace. ClusterRoute : A ClusterRoute could be referenced by any Gateway or ClusterGateway. Benefits Easy to model with RBAC. API validation tied directly to each resource. Downsides New resources to deal with - more informers, clients, documentation, etc. Harder to expand with additional options in the future - may just end up with tons of API resources to cover all use cases.","title":"New API Resources"},{"location":"security-model/#boolean-multi-namespace-route-indicator-on-gatewayclass","text":"Instead of having the routeNamespaceSelector field on GatewayClass, we would use a boolean multiNamespaceRoutes field to indicate if Gateways of this class can target routes in multiple namespaces. This would default to false. A false value here would indicate that routes could only be targeted in the current namespace. Benefits Helpful for multi-tenant use cases with many isolated Gateways. Simple configuration with an easy to understand default value. Downsides GatewayClass admins are unable to partially limit namespaces that can be targeted by Gateways. Admins would have to choose between allowing access to Routes in all namespaces or only the local one.","title":"Boolean Multi Namespace Route Indicator on GatewayClass"},{"location":"security-model/#validating-webhook","text":"A validating webhook could potentially handle some of the cross-resource validation necessary for this security model and provide more immediate feedback to end users. Benefits Immediate validation feedback. More validation logic stays in core Service APIs codebase. Downsides Imperfect solution for cross-resource validation. For example, a change to a GatewayClass could affect the validity of corresponding Gateway. Additional complexity involved in installing Service APIs in a cluster.","title":"Validating Webhook"},{"location":"simple-gateway/","text":"Deploying a simple Gateway The simplest possible deployment is a Gateway and Route resource which are deployed together by the same owner. This represents a similar kind of model used for Ingress. In this guide, a Gateway and HTTPRoute are deployed which match all HTTP traffic and directs it to a single Service named foo-svc . kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: prod-web spec: gatewayClassName: acme-lb listeners: - protocol: HTTP port: 80 routes: kind: HTTPRoute selector: matchLabels: gateway: prod-web-gw The Gateway represents the instantation of a logical load balancer. It's templated from a hypothetical acme-lb GatewayClass. The Gateway listens for HTTP traffic on port 80. This particular GatewayClass automatically assigns an IP address which will be shown in the Gateway.status after it has been deployed. Gateways bind Routes to themselves via label selection (similar to how Services label select across Pod labels). In this example, the prod-web Gateway will bind any HTTPRoute resources which have the gateway: prod-web-gw label. The label can be any arbitrary label, but using one that identifies the name or capabilities of the Gateway is useful to Route owners and makes the relationship more explicit. More complex bi-directional matching and permissions are possible and explained in other guides. The following HTTPRoute defines how traffic from the Gateway listener is routed to backends. Because there are no host routes or paths specified, this HTTPRoute will match all HTTP traffic that arrives at port 80 of the load balancer and send it to the foo-svc Pods. kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: foo labels: gateway: prod-web-gw spec: rules: - forwardTo: - serviceName: foo-svc port: 8080 While Route resources are often used to filter traffic to many different backends (potentially with different owners), this demonstrates the simplest possible route with a single Service backend. This example shows how a service owner can deploy both the Gateway and the HTTPRoute for their usage alone, giving them more control and autonomy for how the service is exposed.","title":"Simple Gateway"},{"location":"simple-gateway/#deploying-a-simple-gateway","text":"The simplest possible deployment is a Gateway and Route resource which are deployed together by the same owner. This represents a similar kind of model used for Ingress. In this guide, a Gateway and HTTPRoute are deployed which match all HTTP traffic and directs it to a single Service named foo-svc . kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: prod-web spec: gatewayClassName: acme-lb listeners: - protocol: HTTP port: 80 routes: kind: HTTPRoute selector: matchLabels: gateway: prod-web-gw The Gateway represents the instantation of a logical load balancer. It's templated from a hypothetical acme-lb GatewayClass. The Gateway listens for HTTP traffic on port 80. This particular GatewayClass automatically assigns an IP address which will be shown in the Gateway.status after it has been deployed. Gateways bind Routes to themselves via label selection (similar to how Services label select across Pod labels). In this example, the prod-web Gateway will bind any HTTPRoute resources which have the gateway: prod-web-gw label. The label can be any arbitrary label, but using one that identifies the name or capabilities of the Gateway is useful to Route owners and makes the relationship more explicit. More complex bi-directional matching and permissions are possible and explained in other guides. The following HTTPRoute defines how traffic from the Gateway listener is routed to backends. Because there are no host routes or paths specified, this HTTPRoute will match all HTTP traffic that arrives at port 80 of the load balancer and send it to the foo-svc Pods. kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: foo labels: gateway: prod-web-gw spec: rules: - forwardTo: - serviceName: foo-svc port: 8080 While Route resources are often used to filter traffic to many different backends (potentially with different owners), this demonstrates the simplest possible route with a single Service backend. This example shows how a service owner can deploy both the Gateway and the HTTPRoute for their usage alone, giving them more control and autonomy for how the service is exposed.","title":"Deploying a simple Gateway"},{"location":"spec/","text":"Packages: networking.x-k8s.io/v1alpha1 networking.x-k8s.io/v1alpha1 Package v1alpha1 contains API Schema definitions for the networking.x-k8s.io API group. Resource Types: BackendPolicy Gateway GatewayClass HTTPRoute TCPRoute TLSRoute UDPRoute BackendPolicy BackendPolicy defines policies associated with backends. For the purpose of this API, a backend is defined as any resource that a route can forward traffic to. A common example of a backend is a Service. Configuration that is implementation specific may be represented with similar implementation specific custom resources. Field Description apiVersion string networking.x-k8s.io/v1alpha1 kind string BackendPolicy metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec BackendPolicySpec backendRefs []BackendRef BackendRefs define which backends this policy should be applied to. This policy can only apply to backends within the same namespace. If more than one BackendPolicy targets the same backend, precedence must be given to the oldest BackendPolicy. Support: Core tls BackendTLSConfig (Optional) TLS is the TLS configuration for these backends. Support: Extended status BackendPolicyStatus Gateway Gateway represents an instantiation of a service-traffic handling infrastructure by binding Listeners to a set of IP addresses. Implementations should add the gateway-exists-finalizer.networking.x-k8s.io finalizer on the associated GatewayClass whenever Gateway(s) is running. This ensures that a GatewayClass associated with a Gateway(s) is not deleted while in use. Field Description apiVersion string networking.x-k8s.io/v1alpha1 kind string Gateway metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec GatewaySpec gatewayClassName string GatewayClassName used for this Gateway. This is the name of a GatewayClass resource. listeners []Listener Listeners associated with this Gateway. Listeners define logical endpoints that are bound on this Gateway\u2019s addresses. At least one Listener MUST be specified. An implementation MAY group Listeners by Port and then collapse each group of Listeners into a single Listener if the implementation determines that the Listeners in the group are \u201ccompatible\u201d. An implementation MAY also group together and collapse compatible Listeners belonging to different Gateways. For example, an implementation might consider Listeners to be compatible with each other if all of the following conditions are met: Either each Listener within the group specifies the \u201cHTTP\u201d Protocol or each Listener within the group specifies either the \u201cHTTPS\u201d or \u201cTLS\u201d Protocol. Each Listener within the group specifies a Hostname that is unique within the group. As a special case, one Listener within a group may omit Hostname, in which case this Listener matches when no other Listener matches. If the implementation does collapse compatible Listeners, the hostname provided in the incoming client request MUST be matched to a Listener to find the correct set of Routes. The incoming hostname MUST be matched using the Hostname field for each Listener in order of most to least specific. That is, exact matches must be processed before wildcard matches. If this field specifies multiple Listeners that have the same Port value but are not compatible, the implementation must raise a \u201cConflicted\u201d condition in the Listener status. Support: Core addresses []GatewayAddress (Optional) Addresses requested for this gateway. This is optional and behavior can depend on the GatewayClass. If a value is set in the spec and the requested address is invalid, the GatewayClass MUST indicate this in the associated entry in GatewayStatus.Addresses. If no Addresses are specified, the GatewayClass may schedule the Gateway in an implementation-defined manner, assigning an appropriate set of Addresses. The GatewayClass MUST bind all Listeners to every GatewayAddress that it assigns to the Gateway. Support: Core status GatewayStatus GatewayClass GatewayClass describes a class of Gateways available to the user for creating Gateway resources. GatewayClass is a Cluster level resource. Support: Core. Field Description apiVersion string networking.x-k8s.io/v1alpha1 kind string GatewayClass metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec GatewayClassSpec Spec for this GatewayClass. controller string Controller is a domain/path string that indicates the controller that is managing Gateways of this class. Example: \u201cacme.io/gateway-controller\u201d. This field is not mutable and cannot be empty. The format of this field is DOMAIN \u201c/\u201d PATH, where DOMAIN and PATH are valid Kubernetes names ( https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names ). Support: Core parametersRef LocalObjectReference (Optional) ParametersRef is a controller-specific resource containing the configuration parameters corresponding to this class. This is optional if the controller does not require any additional configuration. Parameters resources are implementation specific custom resources. These resources must be cluster-scoped. If the referent cannot be found, the GatewayClass\u2019s \u201cInvalidParameters\u201d status condition will be true. Support: Custom status GatewayClassStatus Status of the GatewayClass. HTTPRoute HTTPRoute is the Schema for the HTTPRoute resource. Field Description apiVersion string networking.x-k8s.io/v1alpha1 kind string HTTPRoute metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec HTTPRouteSpec gateways RouteGateways Gateways defines which Gateways can use this Route. hostnames []Hostname (Optional) Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request. Hostname is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: IPs are not allowed. The : delimiter is not respected because ports are not allowed. Incoming requests are matched against the hostnames before the HTTPRoute rules. If no hostname is specified, traffic is routed based on the HTTPRouteRules. Hostname can be \u201cprecise\u201d which is a domain name without the terminating dot of a network host (e.g. \u201cfoo.example.com\u201d) or \u201cwildcard\u201d, which is a domain name prefixed with a single wildcard label (e.g. \u201c .example.com\u201d). The wildcard character \u2018 \u2019 must appear by itself as the first DNS label and matches only a single label. You cannot have a wildcard label by itself (e.g. Host == \u201c \u201d). Requests will be matched against the Host field in the following order: 1. If Host is precise, the request matches this rule if the http host header is equal to Host. 2. If Host is a wildcard, then the request matches this rule if the http host header is to equal to the suffix (removing the first label) of the wildcard rule. Support: Core tls RouteTLSConfig (Optional) TLS defines the TLS certificate to use for Hostnames defined in this Route. This configuration only takes effect if the AllowRouteOverride field is set to true in the associated Gateway resource. Collisions can happen if multiple HTTPRoutes define a TLS certificate for the same hostname. In such a case, conflict resolution guiding principles apply, specificallly, if hostnames are same and two different certificates are specified then the certificate in the oldest resource wins. Please note that HTTP Route-selection takes place after the TLS Handshake (ClientHello). Due to this, TLS certificate defined here will take precedence even if the request has the potential to match multiple routes (in case multiple HTTPRoutes share the same hostname). Support: Core rules []HTTPRouteRule Rules are a list of HTTP matchers, filters and actions. status HTTPRouteStatus TCPRoute TCPRoute is the Schema for the TCPRoute resource. Field Description apiVersion string networking.x-k8s.io/v1alpha1 kind string TCPRoute metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec TCPRouteSpec rules []TCPRouteRule Rules are a list of TCP matchers and actions. gateways RouteGateways Gateways defines which Gateways can use this Route. status TCPRouteStatus TLSRoute TLSRoute is the Schema for the TLSRoute resource. TLSRoute is similar to TCPRoute but can be configured to match against TLS-specific metadata. This allows more flexibility in matching streams for a given TLS listener. If you need to forward traffic to a single target for a TLS listener, you could chose to use a TCPRoute with a TLS listener. Field Description apiVersion string networking.x-k8s.io/v1alpha1 kind string TLSRoute metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec TLSRouteSpec rules []TLSRouteRule Rules are a list of TLS matchers and actions. gateways RouteGateways Gateways defines which Gateways can use this Route. status TLSRouteStatus UDPRoute UDPRoute is the Schema for the UDPRoute resource. Field Description apiVersion string networking.x-k8s.io/v1alpha1 kind string UDPRoute metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec UDPRouteSpec rules []UDPRouteRule Rules are a list of UDP matchers and actions. gateways RouteGateways Gateways defines which Gateways can use this Route. status UDPRouteStatus AddressType ( string alias) ( Appears on: GatewayAddress ) AddressType defines how a network address is represented as a text string. Valid AddressType values are: \u201cIPAddress\u201d \u201cNamedAddress\u201d BackendPolicyConditionType ( string alias) BackendPolicyConditionType is a type of condition associated with a BackendPolicy. BackendPolicySpec ( Appears on: BackendPolicy ) BackendPolicySpec defines desired policy for a backend. Field Description backendRefs []BackendRef BackendRefs define which backends this policy should be applied to. This policy can only apply to backends within the same namespace. If more than one BackendPolicy targets the same backend, precedence must be given to the oldest BackendPolicy. Support: Core tls BackendTLSConfig (Optional) TLS is the TLS configuration for these backends. Support: Extended BackendPolicyStatus ( Appears on: BackendPolicy ) BackendPolicyStatus defines the observed state of BackendPolicy. Conditions that are related to a specific Route or Gateway should be placed on the Route(s) using backends configured by this BackendPolicy. Field Description conditions []Kubernetes meta/v1.Condition Conditions describe the current conditions of the BackendPolicy. BackendRef ( Appears on: BackendPolicySpec ) BackendRef identifies an API object within a known namespace that defaults group to core and resource to services if unspecified. Field Description group string Group is the group of the referent. kind string Kind is the kind of the referent. name string Name is the name of the referent. port PortNumber (Optional) Port is the port of the referent. If unspecified, this policy applies to all ports on the backend. BackendTLSConfig ( Appears on: BackendPolicySpec ) BackendTLSConfig describes TLS configuration for a backend. Field Description certificateAuthorityRef LocalObjectReference (Optional) CertificateAuthorityRef is a reference to a resource that includes trusted CA certificates for the associated backends. If an entry in this list omits or specifies the empty string for both the group and the resource, the resource defaults to \u201csecrets\u201d. An implementation may support other resources (for example, resource \u201cmycertificates\u201d in group \u201cnetworking.acme.io\u201d). When stored in a Secret, certificates must be PEM encoded and specified within the \u201cca.crt\u201d data field of the Secret. Multiple certificates can be specified, concatenated by new lines. Support: Extended options map[string]string (Optional) Options are a list of key/value pairs to give extended options to the provider. Support: Implementation-specific. GatewayAddress ( Appears on: GatewaySpec , GatewayStatus ) GatewayAddress describes an address that can be bound to a Gateway. Field Description type AddressType Type of the Address. This is either \u201cIPAddress\u201d or \u201cNamedAddress\u201d. Support: Extended value string Value. Examples: \u201c1.2.3.4\u201d, \u201c128::1\u201d, \u201cmy-ip-address\u201d. Validity of the values will depend on Type and support by the controller. GatewayAllowType ( string alias) ( Appears on: RouteGateways ) GatewayAllowType specifies which Gateways should be allowed to use a Route. GatewayClassConditionType ( string alias) GatewayClassConditionType is the type of status conditions. This type should be used with the GatewayClassStatus.Conditions field. GatewayClassSpec ( Appears on: GatewayClass ) GatewayClassSpec reflects the configuration of a class of Gateways. Field Description controller string Controller is a domain/path string that indicates the controller that is managing Gateways of this class. Example: \u201cacme.io/gateway-controller\u201d. This field is not mutable and cannot be empty. The format of this field is DOMAIN \u201c/\u201d PATH, where DOMAIN and PATH are valid Kubernetes names ( https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names ). Support: Core parametersRef LocalObjectReference (Optional) ParametersRef is a controller-specific resource containing the configuration parameters corresponding to this class. This is optional if the controller does not require any additional configuration. Parameters resources are implementation specific custom resources. These resources must be cluster-scoped. If the referent cannot be found, the GatewayClass\u2019s \u201cInvalidParameters\u201d status condition will be true. Support: Custom GatewayClassStatus ( Appears on: GatewayClass ) GatewayClassStatus is the current status for the GatewayClass. Field Description conditions []Kubernetes meta/v1.Condition Conditions is the current status from the controller for this GatewayClass. GatewayConditionReason ( string alias) GatewayConditionReason defines the set of reasons that explain why a particular Gateway condition type has been raised. GatewayConditionType ( string alias) GatewayConditionType is a type of condition associated with a Gateway. This type should be used with the GatewayStatus.Conditions field. GatewayReference ( Appears on: RouteGatewayStatus , RouteGateways ) GatewayReference identifies a Gateway in a specified namespace. Field Description name string Name is the name of the referent. namespace string Namespace is the namespace of the referent. GatewaySpec ( Appears on: Gateway ) GatewaySpec defines the desired state of Gateway. Not all possible combinations of options specified in the Spec are valid. Some invalid configurations can be caught synchronously via a webhook, but there are many cases that will require asynchronous signaling via the GatewayStatus block. Field Description gatewayClassName string GatewayClassName used for this Gateway. This is the name of a GatewayClass resource. listeners []Listener Listeners associated with this Gateway. Listeners define logical endpoints that are bound on this Gateway\u2019s addresses. At least one Listener MUST be specified. An implementation MAY group Listeners by Port and then collapse each group of Listeners into a single Listener if the implementation determines that the Listeners in the group are \u201ccompatible\u201d. An implementation MAY also group together and collapse compatible Listeners belonging to different Gateways. For example, an implementation might consider Listeners to be compatible with each other if all of the following conditions are met: Either each Listener within the group specifies the \u201cHTTP\u201d Protocol or each Listener within the group specifies either the \u201cHTTPS\u201d or \u201cTLS\u201d Protocol. Each Listener within the group specifies a Hostname that is unique within the group. As a special case, one Listener within a group may omit Hostname, in which case this Listener matches when no other Listener matches. If the implementation does collapse compatible Listeners, the hostname provided in the incoming client request MUST be matched to a Listener to find the correct set of Routes. The incoming hostname MUST be matched using the Hostname field for each Listener in order of most to least specific. That is, exact matches must be processed before wildcard matches. If this field specifies multiple Listeners that have the same Port value but are not compatible, the implementation must raise a \u201cConflicted\u201d condition in the Listener status. Support: Core addresses []GatewayAddress (Optional) Addresses requested for this gateway. This is optional and behavior can depend on the GatewayClass. If a value is set in the spec and the requested address is invalid, the GatewayClass MUST indicate this in the associated entry in GatewayStatus.Addresses. If no Addresses are specified, the GatewayClass may schedule the Gateway in an implementation-defined manner, assigning an appropriate set of Addresses. The GatewayClass MUST bind all Listeners to every GatewayAddress that it assigns to the Gateway. Support: Core GatewayStatus ( Appears on: Gateway ) GatewayStatus defines the observed state of Gateway. Field Description addresses []GatewayAddress (Optional) Addresses lists the IP addresses that have actually been bound to the Gateway. These addresses may differ from the addresses in the Spec, e.g. if the Gateway automatically assigns an address from a reserved pool. These addresses should all be of type \u201cIPAddress\u201d. conditions []Kubernetes meta/v1.Condition Conditions describe the current conditions of the Gateway. Implementations should prefer to express Gateway conditions using the GatewayConditionType and GatewayConditionReason constants so that operators and tools can converge on a common vocabulary to describe Gateway state. Known condition types are: \u201cScheduled\u201d \u201cReady\u201d listeners []ListenerStatus (Optional) Listeners provide status for each unique listener port defined in the Spec. GatewayTLSConfig ( Appears on: Listener ) GatewayTLSConfig describes a TLS configuration. References - nginx: https://nginx.org/en/docs/http/configuring_https_servers.html - envoy: https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/auth/cert.proto - haproxy: https://www.haproxy.com/documentation/aloha/9-5/traffic-management/lb-layer7/tls/ - gcp: https://cloud.google.com/load-balancing/docs/use-ssl-policies#creating_an_ssl_policy_with_a_custom_profile - aws: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies - azure: https://docs.microsoft.com/en-us/azure/app-service/configure-ssl-bindings#enforce-tls-1112 Field Description mode TLSModeType Mode defines the TLS behavior for the TLS session initiated by the client. There are two possible modes: - Terminate: The TLS session between the downstream client and the Gateway is terminated at the Gateway. - Passthrough: The TLS session is NOT terminated by the Gateway. This implies that the Gateway can\u2019t decipher the TLS stream except for the ClientHello message of the TLS protocol. CertificateRef field is ignored in this mode. certificateRef LocalObjectReference (Optional) CertificateRef is the reference to Kubernetes object that contain a TLS certificate and private key. This certificate MUST be used for TLS handshakes for the domain this GatewayTLSConfig is associated with. If an entry in this list omits or specifies the empty string for both the group and the resource, the resource defaults to \u201csecrets\u201d. An implementation may support other resources (for example, resource \u201cmycertificates\u201d in group \u201cnetworking.acme.io\u201d). Support: Core (Kubernetes Secrets) Support: Implementation-specific (Other resource types) routeOverride TLSOverridePolicy RouteOverride dictates if TLS settings can be configured via Routes or not. CertificateRef must be defined even if routeOverride.certificate is set to \u2018Allow\u2019 as it will be used as the default certificate for the listener. options map[string]string (Optional) Options are a list of key/value pairs to give extended options to the provider. There variation among providers as to how ciphersuites are expressed. If there is a common subset for expressing ciphers then it will make sense to loft that as a core API construct. Support: Implementation-specific. HTTPHeaderMatch ( Appears on: HTTPRouteMatch ) HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request headers. Field Description type HeaderMatchType Type specifies how to match against the value of the header. Support: core (Exact) Support: custom (RegularExpression, ImplementationSpecific) Since RegularExpression PathType has custom conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation\u2019s documentation to determine the supported dialect. HTTP Header name matching MUST be case-insensitive (RFC 2616 - section 4.2). values map[string]string Values is a map of HTTP Headers to be matched. It MUST contain at least one entry. The HTTP header field name to match is the map key, and the value of the HTTP header is the map value. HTTP header field name matching MUST be case-insensitive. Multiple match values are ANDed together, meaning, a request must match all the specified headers to select the route. HTTPPathMatch ( Appears on: HTTPRouteMatch ) HTTPPathMatch describes how to select a HTTP route by matching the HTTP request path. Field Description type PathMatchType Type specifies how to match against the path Value. Support: core (Exact, Prefix) Support: custom (RegularExpression, ImplementationSpecific) Since RegularExpression PathType has custom conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation\u2019s documentation to determine the supported dialect. value string Value of the HTTP path to match against. HTTPRequestHeaderFilter ( Appears on: HTTPRouteFilter ) HTTPRequestHeaderFilter defines configuration for the RequestHeaderModifier filter. Field Description add map[string]string (Optional) Add adds the given header (name, value) to the request before the action. Input: GET /foo HTTP/1.1 Config: add: {\u201cmy-header\u201d: \u201cfoo\u201d} Output: GET /foo HTTP/1.1 my-header: foo Support: Extended remove []string (Optional) Remove the given header(s) from the HTTP request before the action. The value of RemoveHeader is a list of HTTP header names. Note that the header names are case-insensitive [RFC-2616 4.2]. Input: GET /foo HTTP/1.1 My-Header1: ABC My-Header2: DEF My-Header2: GHI Config: remove: [\u201cmy-header1\u201d, \u201cmy-header3\u201d] Output: GET /foo HTTP/1.1 My-Header2: DEF Support: Extended HTTPRequestMirrorFilter ( Appears on: HTTPRouteFilter ) HTTPRequestMirrorFilter defines configuration for the RequestMirror filter. Field Description serviceName string (Optional) ServiceName refers to the name of the Service to mirror matched requests to. When specified, this takes the place of BackendRef. If both BackendRef and ServiceName are specified, ServiceName will be given precedence. If the referent cannot be found, the rule is not included in the route. The controller should raise the \u201cResolvedRefs\u201d condition on the Gateway with the \u201cDegradedRoutes\u201d reason. The gateway status for this route should be updated with a condition that describes the error more specifically. Support: Core backendRef LocalObjectReference (Optional) BackendRef is a local object reference to mirror matched requests to. If both BackendRef and ServiceName are specified, ServiceName will be given precedence. If the referent cannot be found, the rule is not included in the route. The controller should raise the \u201cResolvedRefs\u201d condition on the Gateway with the \u201cDegradedRoutes\u201d reason. The gateway status for this route should be updated with a condition that describes the error more specifically. Support: Custom port PortNumber Port specifies the destination port number to use for the backend referenced by the ServiceName or BackendRef field. HTTPRouteFilter ( Appears on: HTTPRouteForwardTo , HTTPRouteRule ) HTTPRouteFilter defines additional processing steps that must be completed during the request or response lifecycle. HTTPRouteFilters are meant as an extension point to express additional processing that may be done in Gateway implementations. Some examples include request or response modification, implementing authentication strategies, rate-limiting, and traffic shaping. API guarantee/conformance is defined based on the type of the filter. TODO(hbagdi): re-render CRDs once controller-tools supports union tags: - https://github.com/kubernetes-sigs/controller-tools/pull/298 - https://github.com/kubernetes-sigs/controller-tools/issues/461 Field Description type HTTPRouteFilterType Type identifies the type of filter to apply. As with other API fields, types are classified into three conformance levels: Core: Filter types and their corresponding configuration defined by \u201cSupport: Core\u201d in this package, e.g. \u201cRequestHeaderModifier\u201d. All implementations must support core filters. Extended: Filter types and their corresponding configuration defined by \u201cSupport: Extended\u201d in this package, e.g. \u201cRequestMirror\u201d. Implementers are encouraged to support extended filters. Custom: Filters that are defined and supported by specific vendors. In the future, filters showing convergence in behavior across multiple implementations will be considered for inclusion in extended or core conformance levels. Filter-specific configuration for such filters is specified using the ExtensionRef field. Type should be set to \u201cExtensionRef\u201d for custom filters. Implementers are encouraged to define custom implementation types to extend the core API with implementation-specific behavior. requestHeaderModifier HTTPRequestHeaderFilter (Optional) RequestHeaderModifier defines a schema for a filter that modifies request headers. Support: Core requestMirror HTTPRequestMirrorFilter (Optional) RequestMirror defines a schema for a filter that mirrors requests. Support: Extended extensionRef LocalObjectReference (Optional) ExtensionRef is an optional, implementation-specific extension to the \u201cfilter\u201d behavior. For example, resource \u201cmyroutefilter\u201d in group \u201cnetworking.acme.io\u201d). ExtensionRef MUST NOT be used for core and extended filters. Support: Implementation-specific HTTPRouteFilterType ( string alias) ( Appears on: HTTPRouteFilter ) HTTPRouteFilterType identifies a type of HTTPRoute filter. HTTPRouteForwardTo ( Appears on: HTTPRouteRule ) HTTPRouteForwardTo defines how a HTTPRoute should forward a request. Field Description serviceName string (Optional) ServiceName refers to the name of the Service to forward matched requests to. When specified, this takes the place of BackendRef. If both BackendRef and ServiceName are specified, ServiceName will be given precedence. If the referent cannot be found, the route must be dropped from the Gateway. The controller should raise the \u201cResolvedRefs\u201d condition on the Gateway with the \u201cDroppedRoutes\u201d reason. The gateway status for this route should be updated with a condition that describes the error more specifically. The protocol to use should be specified with the AppProtocol field on Service resources. This field was introduced in Kubernetes 1.18. If using an earlier version of Kubernetes, a networking.x-k8s.io/app-protocol annotation on the BackendPolicy resource may be used to define the protocol. If the AppProtocol field is available, this annotation should not be used. The AppProtocol field, when populated, takes precedence over the annotation in the BackendPolicy resource. For custom backends, it is encouraged to add a semantically-equivalent field in the Custom Resource Definition. Support: Core backendRef LocalObjectReference (Optional) BackendRef is a reference to a backend to forward matched requests to. If both BackendRef and ServiceName are specified, ServiceName will be given precedence. If the referent cannot be found, the route must be dropped from the Gateway. The controller should raise the \u201cResolvedRefs\u201d condition on the Gateway with the \u201cDroppedRoutes\u201d reason. The gateway status for this route should be updated with a condition that describes the error more specifically. Support: Custom port PortNumber Port specifies the destination port number to use for the backend referenced by the ServiceName or BackendRef field. Support: Core weight int32 Weight specifies the proportion of HTTP requests forwarded to the backend referenced by the ServiceName or BackendRef field. This is computed as weight/(sum of all weights in this ForwardTo list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100. If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1. Support: Core filters []HTTPRouteFilter (Optional) Filters defined at this-level should be executed if and only if the request is being forwarded to the backend defined here. Support: Custom (For broader support of filters, use the Filters field in HTTPRouteRule.) HTTPRouteMatch ( Appears on: HTTPRouteRule ) HTTPRouteMatch defines the predicate used to match requests to a given action. Multiple match types are ANDed together, i.e. the match will evaluate to true only if all conditions are satisfied. For example, the match below will match a HTTP request only if its path starts with /foo AND it contains the version: \"1\" header: match: path: value: \"/foo\" headers: values: version: \"1\" Field Description path HTTPPathMatch Path specifies a HTTP request path matcher. If this field is not specified, a default prefix match on the \u201c/\u201d path is provided. headers HTTPHeaderMatch (Optional) Headers specifies a HTTP request header matcher. extensionRef LocalObjectReference (Optional) ExtensionRef is an optional, implementation-specific extension to the \u201cmatch\u201d behavior. For example, resource \u201cmyroutematcher\u201d in group \u201cnetworking.acme.io\u201d. If the referent cannot be found, the rule is not included in the route. The controller should raise the \u201cResolvedRefs\u201d condition on the Gateway with the \u201cDegradedRoutes\u201d reason. The gateway status for this route should be updated with a condition that describes the error more specifically. Support: custom HTTPRouteRule ( Appears on: HTTPRouteSpec ) HTTPRouteRule defines semantics for matching an HTTP request based on conditions, optionally executing additional processing steps, and forwarding the request to an API object. Field Description matches []HTTPRouteMatch Matches define conditions used for matching the rule against incoming HTTP requests. Each match is independent, i.e. this rule will be matched if any one of the matches is satisfied. For example, take the following matches configuration: matches: - path: value: \"/foo\" headers: values: version: \"2\" - path: value: \"/v2/foo\" For a request to match against this rule, a request should satisfy EITHER of the two conditions: path prefixed with /foo AND contains the header version: \"2\" path prefix of /v2/foo See the documentation for HTTPRouteMatch on how to specify multiple match conditions that should be ANDed together. If no matches are specified, the default is a prefix path match on \u201c/\u201d, which has the effect of matching every HTTP request. A client request may match multiple HTTP route rules. Matching precedence MUST be determined in order of the following criteria, continuing on ties: * The longest matching hostname. * The longest matching path. * The largest number of header matches * The oldest Route based on creation timestamp. For example, a Route with a creation timestamp of \u201c2020-09-08 01:02:03\u201d is given precedence over a Route with a creation timestamp of \u201c2020-09-08 01:02:04\u201d. * The Route appearing first in alphabetical order (namespace/name) for example, foo/bar is given precedence over foo/baz. filters []HTTPRouteFilter (Optional) Filters define the filters that are applied to requests that match this rule. The effects of ordering of multiple behaviors are currently unspecified. This can change in the future based on feedback during the alpha stage. Conformance-levels at this level are defined based on the type of filter: - ALL core filters MUST be supported by all implementations. - Implementers are encouraged to support extended filters. - Implementation-specific custom filters have no API guarantees across implementations. Specifying a core filter multiple times has unspecified or custom conformance. Support: core forwardTo []HTTPRouteForwardTo (Optional) ForwardTo defines the backend(s) where matching requests should be sent. If unspecified, the rule performs no forwarding. If unspecified and no filters are specified that would result in a response being sent, a 503 error code is returned. HTTPRouteSpec ( Appears on: HTTPRoute ) HTTPRouteSpec defines the desired state of HTTPRoute Field Description gateways RouteGateways Gateways defines which Gateways can use this Route. hostnames []Hostname (Optional) Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request. Hostname is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: IPs are not allowed. The : delimiter is not respected because ports are not allowed. Incoming requests are matched against the hostnames before the HTTPRoute rules. If no hostname is specified, traffic is routed based on the HTTPRouteRules. Hostname can be \u201cprecise\u201d which is a domain name without the terminating dot of a network host (e.g. \u201cfoo.example.com\u201d) or \u201cwildcard\u201d, which is a domain name prefixed with a single wildcard label (e.g. \u201c .example.com\u201d). The wildcard character \u2018 \u2019 must appear by itself as the first DNS label and matches only a single label. You cannot have a wildcard label by itself (e.g. Host == \u201c \u201d). Requests will be matched against the Host field in the following order: 1. If Host is precise, the request matches this rule if the http host header is equal to Host. 2. If Host is a wildcard, then the request matches this rule if the http host header is to equal to the suffix (removing the first label) of the wildcard rule. Support: Core tls RouteTLSConfig (Optional) TLS defines the TLS certificate to use for Hostnames defined in this Route. This configuration only takes effect if the AllowRouteOverride field is set to true in the associated Gateway resource. Collisions can happen if multiple HTTPRoutes define a TLS certificate for the same hostname. In such a case, conflict resolution guiding principles apply, specificallly, if hostnames are same and two different certificates are specified then the certificate in the oldest resource wins. Please note that HTTP Route-selection takes place after the TLS Handshake (ClientHello). Due to this, TLS certificate defined here will take precedence even if the request has the potential to match multiple routes (in case multiple HTTPRoutes share the same hostname). Support: Core rules []HTTPRouteRule Rules are a list of HTTP matchers, filters and actions. HTTPRouteStatus ( Appears on: HTTPRoute ) HTTPRouteStatus defines the observed state of HTTPRoute. Field Description RouteStatus RouteStatus (Members of RouteStatus are embedded into this type.) HeaderMatchType ( string alias) ( Appears on: HTTPHeaderMatch ) HeaderMatchType specifies the semantics of how HTTP header values should be compared. Valid HeaderMatchType values are: \u201cExact\u201d \u201cRegularExpression\u201d \u201cImplementationSpecific\u201d Hostname ( string alias) ( Appears on: HTTPRouteSpec , Listener , ListenerStatus , TLSRouteMatch ) Hostname is used to specify a hostname that should be matched. Listener ( Appears on: GatewaySpec ) Listener embodies the concept of a logical endpoint where a Gateway can accept network connections. Each listener in a Gateway must have a unique combination of Hostname, Port, and Protocol. This will be enforced by a validating webhook. Field Description hostname Hostname (Optional) Hostname specifies the virtual hostname to match for protocol types that define this concept. When unspecified or \u201c \u201d, all hostnames are matched. This field can be omitted for protocols that don\u2019t require hostname based matching. Hostname is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: IP literals are not allowed. The : delimiter is not respected because ports are not allowed. Hostname can be \u201cprecise\u201d which is a domain name without the terminating dot of a network host (e.g. \u201cfoo.example.com\u201d) or \u201cwildcard\u201d, which is a domain name prefixed with a single wildcard label (e.g. \u201c .example.com\u201d). The wildcard character \u2018 \u2019 must appear by itself as the first DNS label and matches only a single label. Support: Core port PortNumber Port is the network port. Multiple listeners may use the same port, subject to the Listener compatibility rules. Support: Core protocol ProtocolType Protocol specifies the network protocol this listener expects to receive. The GatewayClass MUST apply the Hostname match appropriately for each protocol: For the \u201cTLS\u201d protocol, the Hostname match MUST be applied to the SNI server name offered by the client. For the \u201cHTTP\u201d protocol, the Hostname match MUST be applied to the host portion of the effective request URI or the :authority pseudo-header For the \u201cHTTPS\u201d protocol, the Hostname match MUST be applied at both the TLS and HTTP protocol layers. Support: Core tls GatewayTLSConfig (Optional) TLS is the TLS configuration for the Listener. This field is required if the Protocol field is \u201cHTTPS\u201d or \u201cTLS\u201d and ignored otherwise. The association of SNIs to Certificate defined in GatewayTLSConfig is defined based on the Hostname field for this listener. The GatewayClass MUST use the longest matching SNI out of all available certificates for any TLS handshake. Support: Core routes RouteBindingSelector Routes specifies a schema for associating routes with the Listener using selectors. A Route is a resource capable of servicing a request and allows a cluster operator to expose a cluster resource (i.e. Service) by externally-reachable URL, load-balance traffic and terminate SSL/TLS. Typically, a route is a \u201cHTTPRoute\u201d or \u201cTCPRoute\u201d in group \u201cnetworking.x-k8s.io\u201d, however, an implementation may support other types of resources. The Routes selector MUST select a set of objects that are compatible with the application protocol specified in the Protocol field. Although a client request may technically match multiple route rules, only one rule may ultimately receive the request. Matching precedence MUST be determined in order of the following criteria: The most specific match. For example, the most specific HTTPRoute match is determined by the longest matching combination of hostname and path. The oldest Route based on creation timestamp. For example, a Route with a creation timestamp of \u201c2020-09-08 01:02:03\u201d is given precedence over a Route with a creation timestamp of \u201c2020-09-08 01:02:04\u201d. If everything else is equivalent, the Route appearing first in alphabetical order (namespace/name) should be given precedence. For example, foo/bar is given precedence over foo/baz. All valid portions of a Route selected by this field should be supported. Invalid portions of a Route can be ignored (sometimes that will mean the full Route). If a portion of a Route transitions from valid to invalid, support for that portion of the Route should be dropped to ensure consistency. For example, even if a filter specified by a Route is invalid, the rest of the Route should still be supported. Support: Core ListenerConditionReason ( string alias) ListenerConditionReason defines the set of reasons that explain why a particular Listener condition type has been raised. ListenerConditionType ( string alias) ListenerConditionType is a type of condition associated with the listener. This type should be used with the ListenerStatus.Conditions field. ListenerStatus ( Appears on: GatewayStatus ) ListenerStatus is the status associated with a Listener. Field Description port PortNumber Port is the unique Listener port value for which this message is reporting the status. protocol ProtocolType Protocol is the Listener protocol value for which this message is reporting the status. hostname Hostname (Optional) Hostname is the Listener hostname value for which this message is reporting the status. conditions []Kubernetes meta/v1.Condition Conditions describe the current condition of this listener. LocalObjectReference ( Appears on: BackendTLSConfig , GatewayClassSpec , GatewayTLSConfig , HTTPRequestMirrorFilter , HTTPRouteFilter , HTTPRouteForwardTo , HTTPRouteMatch , RouteForwardTo , RouteTLSConfig , TCPRouteMatch , TLSRouteMatch , UDPRouteMatch ) LocalObjectReference identifies an API object within a known namespace. Field Description group string Group is the group of the referent. kind string Kind is kind of the referent. name string Name is the name of the referent. PathMatchType ( string alias) ( Appears on: HTTPPathMatch ) PathMatchType specifies the semantics of how HTTP paths should be compared. Valid PathMatchType values are: \u201cExact\u201d \u201cPrefix\u201d \u201cRegularExpression\u201d \u201cImplementationSpecific\u201d Prefix and Exact paths must be syntactically valid: - Must begin with the \u2018/\u2019 character - Must not contain consecutive \u2018/\u2019 characters (e.g. /foo///, //). - For prefix paths, a trailing \u2018/\u2019 character in the Path is ignored, e.g. /abc and /abc/ specify the same match. PortNumber ( int32 alias) ( Appears on: BackendRef , HTTPRequestMirrorFilter , HTTPRouteForwardTo , Listener , ListenerStatus , RouteForwardTo ) PortNumber defines a network port. ProtocolType ( string alias) ( Appears on: Listener , ListenerStatus ) ProtocolType defines the application protocol accepted by a Listener. Implementations are not required to accept all the defined protocols. If an implementation does not support a specified protocol, it should raise a \u201cDetached\u201d condition for the affected Listener with a reason of \u201cUnsupportedProtocol\u201d. Core ProtocolType values are: \u201cHTTP\u201d \u201cHTTPS\u201d \u201cTLS\u201d \u201cTCP\u201d \u201cUDP\u201d Implementations can define their own protocols if a core ProtocolType does not exist. Such definitions must use prefixed name, such as mycompany.com/my-custom-protocol . Un-prefixed names are reserved for core protocols. Any protocol defined by implementations will fall under custom conformance. RouteBindingSelector ( Appears on: Listener ) RouteBindingSelector defines a schema for associating routes with the Gateway. If Namespaces and Selector are defined, only routes matching both selectors are associated with the Gateway. Field Description namespaces RouteNamespaces Namespaces indicates in which namespaces Routes should be selected for this Gateway. This is restricted to the namespace of this Gateway by default. Support: Core selector Kubernetes meta/v1.LabelSelector (Optional) Selector specifies a set of route labels used for selecting routes to associate with the Gateway. If RouteSelector is defined, only routes matching the RouteSelector are associated with the Gateway. An empty RouteSelector matches all routes. Support: Core group string Group is the group of the route resource to select. Omitting the value or specifying the empty string indicates the networking.x-k8s.io API group. For example, use the following to select an HTTPRoute: routes: kind: HTTPRoute Otherwise, if an alternative API group is desired, specify the desired group: routes: group: acme.io kind: FooRoute Support: Core kind string Kind is the kind of the route resource to select. Kind MUST correspond to kinds of routes that are compatible with the application protocol specified in the Listener\u2019s Protocol field. If an implementation does not support or recognize this resource type, it SHOULD raise a \u201cConditionInvalidRoutes\u201d condition for the affected Listener. Support: Core RouteConditionType ( string alias) RouteConditionType is a type of condition for a route. RouteForwardTo ( Appears on: TCPRouteRule , TLSRouteRule , UDPRouteRule ) RouteForwardTo defines how a Route should forward a request. Field Description serviceName string (Optional) ServiceName refers to the name of the Service to forward matched requests to. When specified, this takes the place of BackendRef. If both BackendRef and ServiceName are specified, ServiceName will be given precedence. If the referent cannot be found, the rule is not included in the route. The controller should raise the \u201cResolvedRefs\u201d condition on the Gateway with the \u201cDegradedRoutes\u201d reason. The gateway status for this route should be updated with a condition that describes the error more specifically. The protocol to use is defined using AppProtocol field (introduced in Kubernetes 1.18) in the Service resource. In the absence of the AppProtocol field a networking.x-k8s.io/app-protocol annotation on the BackendPolicy resource may be used to define the protocol. If the AppProtocol field is available, this annotation should not be used. The AppProtocol field, when populated, takes precedence over the annotation in the BackendPolicy resource. For custom backends, it is encouraged to add a semantically-equivalent field in the Custom Resource Definition. Support: Core backendRef LocalObjectReference (Optional) BackendRef is a reference to a backend to forward matched requests to. If both BackendRef and ServiceName are specified, ServiceName will be given precedence. If the referent cannot be found, the rule is not included in the route. The controller should raise the \u201cResolvedRefs\u201d condition on the Gateway with the \u201cDegradedRoutes\u201d reason. The gateway status for this route should be updated with a condition that describes the error more specifically. Support: Custom port PortNumber Port specifies the destination port number to use for the backend referenced by the ServiceName or BackendRef field. Support: Core weight int32 Weight specifies the proportion of HTTP requests forwarded to the backend referenced by the ServiceName or BackendRef field. This is computed as weight/(sum of all weights in this ForwardTo list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100. If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1. Support: Extended RouteGatewayStatus ( Appears on: RouteStatus ) RouteGatewayStatus describes the status of a route with respect to an associated Gateway. Field Description gatewayRef GatewayReference GatewayRef is a reference to a Gateway object that is associated with the route. conditions []Kubernetes meta/v1.Condition Conditions describes the status of the route with respect to the Gateway. For example, the \u201cAdmitted\u201d condition indicates whether the route has been admitted or rejected by the Gateway, and why. Note that the route\u2019s availability is also subject to the Gateway\u2019s own status conditions and listener status. RouteGateways ( Appears on: HTTPRouteSpec , TCPRouteSpec , TLSRouteSpec , UDPRouteSpec ) RouteGateways defines which Gateways will be able to use a route. If this field results in preventing the selection of a Route by a Gateway, an \u201cAdmitted\u201d condition with a status of false must be set for the Gateway on that Route. Field Description allow GatewayAllowType Allow indicates which Gateways will be allowed to use this route. Possible values are: * All: Gateways in any namespace can use this route. * FromList: Only Gateways specified in GatewayRefs may use this route. * SameNamespace: Only Gateways in the same namespace may use this route. gatewayRefs []GatewayReference (Optional) GatewayRefs must be specified when Allow is set to \u201cFromList\u201d. In that case, only Gateways referenced in this list will be allowed to use this route. This field is ignored for other values of \u201cAllow\u201d. RouteNamespaces ( Appears on: RouteBindingSelector ) RouteNamespaces indicate which namespaces Routes should be selected from. Field Description from RouteSelectType From indicates where Routes will be selected for this Gateway. Possible values are: * All: Routes in all namespaces may be used by this Gateway. * Selector: Routes in namespaces selected by the selector may be used by this Gateway. * Same: Only Routes in the same namespace may be used by this Gateway. Support: Core selector Kubernetes meta/v1.LabelSelector (Optional) Selector must be specified when From is set to \u201cSelector\u201d. In that case, only Routes in Namespaces matching this Selector will be selected by this Gateway. This field is ignored for other values of \u201cFrom\u201d. Support: Core RouteSelectType ( string alias) ( Appears on: RouteNamespaces ) RouteSelectType specifies where Routes should be selected by a Gateway. RouteStatus ( Appears on: HTTPRouteStatus , TCPRouteStatus , TLSRouteStatus , UDPRouteStatus ) RouteStatus defines the observed state that is required across all route types. Field Description gateways []RouteGatewayStatus Gateways is a list of the Gateways that are associated with the route, and the status of the route with respect to each of these Gateways. When a Gateway selects this route, the controller that manages the Gateway should add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route is modified. A maximum of 100 Gateways will be represented in this list. If this list is full, there may be additional Gateways using this Route that are not included in the list. RouteTLSConfig ( Appears on: HTTPRouteSpec ) RouteTLSConfig describes a TLS configuration defined at the Route level. Field Description certificateRef LocalObjectReference CertificateRef refers to a Kubernetes object that contains a TLS certificate and private key. This certificate MUST be used for TLS handshakes for the domain this RouteTLSConfig is associated with. If an entry in this list omits or specifies the empty string for both the group and kind, the resource defaults to \u201csecrets\u201d. An implementation may support other resources (for example, resource \u201cmycertificates\u201d in group \u201cnetworking.acme.io\u201d). Support: Core (Kubernetes Secrets) Support: Implementation-specific (Other resource types) TCPRouteMatch ( Appears on: TCPRouteRule ) TCPRouteMatch defines the predicate used to match connections to a given action. Field Description extensionRef LocalObjectReference (Optional) ExtensionRef is an optional, implementation-specific extension to the \u201cmatch\u201d behavior. For example, resource \u201cmytcproutematcher\u201d in group \u201cnetworking.acme.io\u201d. If the referent cannot be found, the rule is not included in the route. The controller should raise the \u201cResolvedRefs\u201d condition on the Gateway with the \u201cDegradedRoutes\u201d reason. The gateway status for this route should be updated with a condition that describes the error more specifically. Support: custom TCPRouteRule ( Appears on: TCPRouteSpec ) TCPRouteRule is the configuration for a given rule. Field Description matches []TCPRouteMatch (Optional) Matches define conditions used for matching the rule against incoming TCP connections. Each match is independent, i.e. this rule will be matched if any one of the matches is satisfied. If unspecified, all requests from the associated gateway TCP listener will match. forwardTo []RouteForwardTo ForwardTo defines the backend(s) where matching requests should be sent. TCPRouteSpec ( Appears on: TCPRoute ) TCPRouteSpec defines the desired state of TCPRoute Field Description rules []TCPRouteRule Rules are a list of TCP matchers and actions. gateways RouteGateways Gateways defines which Gateways can use this Route. TCPRouteStatus ( Appears on: TCPRoute ) TCPRouteStatus defines the observed state of TCPRoute Field Description RouteStatus RouteStatus (Members of RouteStatus are embedded into this type.) TLSModeType ( string alias) ( Appears on: GatewayTLSConfig ) TLSModeType type defines behavior of gateway with TLS protocol. TLSOverridePolicy ( Appears on: GatewayTLSConfig ) TLSOverridePolicy defines a schema for overriding TLS settings at the Route level. Field Description certificate TLSRouteOverrideType Certificate dictates if TLS certificates can be configured via Routes. If set to \u2018Allow\u2019, a TLS certificate for a hostname defined in a Route takes precedence over the certificate defined in Gateway. Support: Core TLSRouteMatch ( Appears on: TLSRouteRule ) TLSRouteMatch defines the predicate used to match connections to a given action. Field Description snis []Hostname (Optional) SNIs defines a set of SNI names that should match against the SNI attribute of TLS ClientHello message in TLS handshake. SNI can be \u201cprecise\u201d which is a domain name without the terminating dot of a network host (e.g. \u201cfoo.example.com\u201d) or \u201cwildcard\u201d, which is a domain name prefixed with a single wildcard label (e.g. \u201c .example.com\u201d). The wildcard character \u2018 \u2019 must appear by itself as the first DNS label and matches only a single label. You cannot have a wildcard label by itself (e.g. Host == \u201c \u201d). Requests will be matched against the Host field in the following order: If SNI is precise, the request matches this rule if the SNI in ClientHello is equal to one of the defined SNIs. If SNI is a wildcard, then the request matches this rule if the SNI is to equal to the suffix (removing the first label) of the wildcard rule. If SNIs is unspecified, all requests associated with the gateway TLS listener will match. This can be used to define a default backend for a TLS listener. Support: core extensionRef LocalObjectReference (Optional) ExtensionRef is an optional, implementation-specific extension to the \u201cmatch\u201d behavior. For example, resource \u201cmytlsroutematcher\u201d in group \u201cnetworking.acme.io\u201d. If the referent cannot be found, the rule is not included in the route. The controller should raise the \u201cResolvedRefs\u201d condition on the Gateway with the \u201cDegradedRoutes\u201d reason. The gateway status for this route should be updated with a condition that describes the error more specifically. Support: custom TLSRouteOverrideType ( string alias) ( Appears on: TLSOverridePolicy ) TLSRouteOverrideType type defines the level of allowance for Routes to override a specific TLS setting. TLSRouteRule ( Appears on: TLSRouteSpec ) TLSRouteRule is the configuration for a given rule. Field Description matches []TLSRouteMatch (Optional) Matches define conditions used for matching the rule against an incoming TLS handshake. Each match is independent, i.e. this rule will be matched if any one of the matches is satisfied. If unspecified, all requests from the associated gateway TLS listener will match. forwardTo []RouteForwardTo ForwardTo defines the backend(s) where matching requests should be sent. TLSRouteSpec ( Appears on: TLSRoute ) TLSRouteSpec defines the desired state of TLSRoute Field Description rules []TLSRouteRule Rules are a list of TLS matchers and actions. gateways RouteGateways Gateways defines which Gateways can use this Route. TLSRouteStatus ( Appears on: TLSRoute ) TLSRouteStatus defines the observed state of TLSRoute Field Description RouteStatus RouteStatus (Members of RouteStatus are embedded into this type.) UDPRouteMatch ( Appears on: UDPRouteRule ) UDPRouteMatch defines the predicate used to match packets to a given action. Field Description extensionRef LocalObjectReference (Optional) ExtensionRef is an optional, implementation-specific extension to the \u201cmatch\u201d behavior. For example, resource \u201cmyudproutematcher\u201d in group \u201cnetworking.acme.io\u201d. If the referent cannot be found, the rule is not included in the route. The controller should raise the \u201cResolvedRefs\u201d condition on the Gateway with the \u201cDegradedRoutes\u201d reason. The gateway status for this route should be updated with a condition that describes the error more specifically. Support: custom UDPRouteRule ( Appears on: UDPRouteSpec ) UDPRouteRule is the configuration for a given rule. Field Description matches []UDPRouteMatch (Optional) Matches define conditions used for matching the rule against incoming UDP connections. Each match is independent, i.e. this rule will be matched if any one of the matches is satisfied. If unspecified, all requests from the associated gateway UDP listener will match. forwardTo []RouteForwardTo ForwardTo defines the backend(s) where matching requests should be sent. UDPRouteSpec ( Appears on: UDPRoute ) UDPRouteSpec defines the desired state of UDPRoute. Field Description rules []UDPRouteRule Rules are a list of UDP matchers and actions. gateways RouteGateways Gateways defines which Gateways can use this Route. UDPRouteStatus ( Appears on: UDPRoute ) UDPRouteStatus defines the observed state of UDPRoute. Field Description RouteStatus RouteStatus (Members of RouteStatus are embedded into this type.) Generated with gen-crd-api-reference-docs .","title":"API specification"},{"location":"tls/","text":"TLS details Service APIs allow for a variety of ways to configure TLS. This document lays out various TLS settings and gives general guidelines on how to use them effectively. Client/Server and TLS For Gateways, there are two connections involved: downstream : This is the connection between the client and the Gateway. upstream : This is the connection between the Gateway and backend resources specified by routes. These backend resources will usually be Services. With Service APIs, TLS configuration of downstream and upstream connections is managed independently. Please note that in case of Passthrough TLS mode, no TLS settings take effect as the TLS session from the client is NOT terminated at the Gateway. The rest of the document assumes that TLS is being terminated at the Gateway, which is the default setting. Downstream TLS Downstream TLS settings are configured using listeners at the Gateway level. Listeners and TLS Listeners expose the TLS setting on a per domain or sub-domain basis. TLS settings of a listener are applied to all domains that satisfy the hostname criteria. In the following example, the Gateway serves the TLS certificate defined in the default-cert Secret resource for all requests. Although, the example refers to HTTPS protocol, one can also use the same feature for TLS-only protocol along with TLSRoutes. listeners: - protocol: HTTPS # Other possible value is `TLS` port: 443 tls: mode: Terminate certificateRef: kind: Secret group: core name: default-cert routeOverride: certificate: Deny If hostname.match is set to Exact , then the TLS settings apply to only the specific hostname that is set in hostname.name . Specifying tls.routeOverride.certificate: Deny is recommended because it centralizes TLS configuration within the Gateway specification and should suffice for the majority of use-cases. Please take a look at the examples below for various alternatives. Routes and TLS If listeners[].tls.routeOverride.certificate is set to Allow , TLS certificates can be configured on routes that are bound to the Gateway. This feature is primarily meant for a cluster with a self-service model where Application developers bring their own TLS certificates. This feature also mirrors the behavior of TLS as defined in the Ingress v1 resource. One should use this feature only when the Cluster Operator wishes to delegate TLS configuration to the Application Developer. With this feature, the certificate defined in the route overrides any certificate defined in the Gateway. When using this feature, please note that the TLS certificate to serve is chosen before an HTTPRoute is selected. This is because the TLS handshake is completed before an HTTP request is sent from the client. TLS Certificate in Route provides an example of how this feature can be used. Examples TLS in listener In this example, the Gateway is configured to serve the foo.example.com and bar.example.com domains. The certificate for these domains is specified in the Gateway. kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: tls-basic spec: gatewayClassName: acme-lb listeners: - protocol: HTTPS port: 443 hostname: foo.example.com tls: certificateRef: kind: Secret group: core name: foo-example-com-cert routeOverride: certificate: Deny routes: kind: HTTPRoute - protocol: HTTPS port: 443 hostname: bar.example.com tls: certificateRef: kind: Secret group: core name: bar-example-com-cert routeOverride: certificate: Deny routes: kind: HTTPRoute Wildcard TLS listeners In this example, the Gateway is configured with a wildcard certificate for *.example.com and a different certificate for foo.example.com . Since a specific match takes priority, the Gateway will serve foo-example-com-cert for requests to foo.example.com and wildcard-example-com-cert for all other requests. kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: wildcard-tls-gateway spec: gatewayClassName: acme-lb listeners: - protocol: HTTPS port: 443 hostname: foo.example.com tls: certificateRef: kind: Secret group: core name: foo-example-com-cert routeOverride: certificate: Deny routes: kind: HTTPRoute - protocol: HTTPS port: 443 hostname: \"*.example.com\" tls: certificateRef: kind: Secret group: core name: wildcard-example-com-cert routeOverride: certificate: Deny routes: kind: HTTPRoute TLS Certificate in Route In this example, the Gateway is configured with a default certificate that will be served for all hostnames. In addition, tls.routeOverride.certificate is set to Allow , meaning routes can specify TLS certificates for any domains. Next, there are two HTTPRoute resources which specify certificates for foo.example.com and bar.example.com . kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: cert-in-route-gateway spec: gatewayClassName: acme-lb listeners: - protocol: HTTP port: 80 routes: kind: HTTPRoute - protocol: HTTPS port: 443 tls: mode: Terminate certificateRef: kind: Secret group: core name: default-cert routeOverride: certificate: Allow routes: kind: HTTPRoute --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-app-1 spec: hostnames: - \"foo.example.com\" tls: certificateRef: kind: Secret group: core name: foo-example-com-cert rules: - matches: - path: type: Prefix value: / forwardTo: - serviceName: my-service port: 8080 --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-app-2 spec: hostnames: - \"bar.example.com\" tls: certificateRef: kind: Secret group: core name: bar-example-com-cert rules: - matches: - path: type: Prefix value: / forwardTo: - serviceName: my-service port: 8080 Upstream TLS Upstream TLS configuration applies to the connection between the Gateway and Service. There is only one way to configure upstream TLS: using the BackendPolicy resource. Please note that the TLS configuration is related to the Service or backend resource and not related to a specific route resource. Example The following example shows how upstream TLS can be configured. We have omitted downstream TLS configuration for simplicity. As noted before, it doesn't matter how downstream TLS is configured for the specific listener or route. kind: BackendPolicy apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: my-app annotations: networking.x-k8s.io/app-protocol: https spec: backendRefs: - name: my-service group: core kind: Service port: 443 tls: certificateAuthorityRef: name: my-cluster-ca group: core kind: Secret options: {} --- apiVersion: v1 kind: Service metadata: name: my-service spec: ports: - name: http port: 80 targetPort: 8000 - name: https port: 443 targetPort: 8443 selector: app: my-service --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: my-service-route spec: hostnames: - \"foo.com\" rules: - matches: - path: type: Prefix value: / forwardTo: - serviceName: my-service port: 8443 Extensions Both upstream and downstream TLS configs provide an options map to add additional TLS settings for implementation-specific features. Some examples of features that could go in here would be TLS version restrictions, or ciphers to use.","title":"TLS"},{"location":"tls/#tls-details","text":"Service APIs allow for a variety of ways to configure TLS. This document lays out various TLS settings and gives general guidelines on how to use them effectively.","title":"TLS details"},{"location":"tls/#clientserver-and-tls","text":"For Gateways, there are two connections involved: downstream : This is the connection between the client and the Gateway. upstream : This is the connection between the Gateway and backend resources specified by routes. These backend resources will usually be Services. With Service APIs, TLS configuration of downstream and upstream connections is managed independently. Please note that in case of Passthrough TLS mode, no TLS settings take effect as the TLS session from the client is NOT terminated at the Gateway. The rest of the document assumes that TLS is being terminated at the Gateway, which is the default setting.","title":"Client/Server and TLS"},{"location":"tls/#downstream-tls","text":"Downstream TLS settings are configured using listeners at the Gateway level.","title":"Downstream TLS"},{"location":"tls/#listeners-and-tls","text":"Listeners expose the TLS setting on a per domain or sub-domain basis. TLS settings of a listener are applied to all domains that satisfy the hostname criteria. In the following example, the Gateway serves the TLS certificate defined in the default-cert Secret resource for all requests. Although, the example refers to HTTPS protocol, one can also use the same feature for TLS-only protocol along with TLSRoutes. listeners: - protocol: HTTPS # Other possible value is `TLS` port: 443 tls: mode: Terminate certificateRef: kind: Secret group: core name: default-cert routeOverride: certificate: Deny If hostname.match is set to Exact , then the TLS settings apply to only the specific hostname that is set in hostname.name . Specifying tls.routeOverride.certificate: Deny is recommended because it centralizes TLS configuration within the Gateway specification and should suffice for the majority of use-cases. Please take a look at the examples below for various alternatives.","title":"Listeners and TLS"},{"location":"tls/#routes-and-tls","text":"If listeners[].tls.routeOverride.certificate is set to Allow , TLS certificates can be configured on routes that are bound to the Gateway. This feature is primarily meant for a cluster with a self-service model where Application developers bring their own TLS certificates. This feature also mirrors the behavior of TLS as defined in the Ingress v1 resource. One should use this feature only when the Cluster Operator wishes to delegate TLS configuration to the Application Developer. With this feature, the certificate defined in the route overrides any certificate defined in the Gateway. When using this feature, please note that the TLS certificate to serve is chosen before an HTTPRoute is selected. This is because the TLS handshake is completed before an HTTP request is sent from the client. TLS Certificate in Route provides an example of how this feature can be used.","title":"Routes and TLS"},{"location":"tls/#examples","text":"","title":"Examples"},{"location":"tls/#tls-in-listener","text":"In this example, the Gateway is configured to serve the foo.example.com and bar.example.com domains. The certificate for these domains is specified in the Gateway. kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: tls-basic spec: gatewayClassName: acme-lb listeners: - protocol: HTTPS port: 443 hostname: foo.example.com tls: certificateRef: kind: Secret group: core name: foo-example-com-cert routeOverride: certificate: Deny routes: kind: HTTPRoute - protocol: HTTPS port: 443 hostname: bar.example.com tls: certificateRef: kind: Secret group: core name: bar-example-com-cert routeOverride: certificate: Deny routes: kind: HTTPRoute","title":"TLS in listener"},{"location":"tls/#wildcard-tls-listeners","text":"In this example, the Gateway is configured with a wildcard certificate for *.example.com and a different certificate for foo.example.com . Since a specific match takes priority, the Gateway will serve foo-example-com-cert for requests to foo.example.com and wildcard-example-com-cert for all other requests. kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: wildcard-tls-gateway spec: gatewayClassName: acme-lb listeners: - protocol: HTTPS port: 443 hostname: foo.example.com tls: certificateRef: kind: Secret group: core name: foo-example-com-cert routeOverride: certificate: Deny routes: kind: HTTPRoute - protocol: HTTPS port: 443 hostname: \"*.example.com\" tls: certificateRef: kind: Secret group: core name: wildcard-example-com-cert routeOverride: certificate: Deny routes: kind: HTTPRoute","title":"Wildcard TLS listeners"},{"location":"tls/#tls-certificate-in-route","text":"In this example, the Gateway is configured with a default certificate that will be served for all hostnames. In addition, tls.routeOverride.certificate is set to Allow , meaning routes can specify TLS certificates for any domains. Next, there are two HTTPRoute resources which specify certificates for foo.example.com and bar.example.com . kind: Gateway apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: cert-in-route-gateway spec: gatewayClassName: acme-lb listeners: - protocol: HTTP port: 80 routes: kind: HTTPRoute - protocol: HTTPS port: 443 tls: mode: Terminate certificateRef: kind: Secret group: core name: default-cert routeOverride: certificate: Allow routes: kind: HTTPRoute --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-app-1 spec: hostnames: - \"foo.example.com\" tls: certificateRef: kind: Secret group: core name: foo-example-com-cert rules: - matches: - path: type: Prefix value: / forwardTo: - serviceName: my-service port: 8080 --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: http-app-2 spec: hostnames: - \"bar.example.com\" tls: certificateRef: kind: Secret group: core name: bar-example-com-cert rules: - matches: - path: type: Prefix value: / forwardTo: - serviceName: my-service port: 8080","title":"TLS Certificate in Route"},{"location":"tls/#upstream-tls","text":"Upstream TLS configuration applies to the connection between the Gateway and Service. There is only one way to configure upstream TLS: using the BackendPolicy resource. Please note that the TLS configuration is related to the Service or backend resource and not related to a specific route resource.","title":"Upstream TLS"},{"location":"tls/#example","text":"The following example shows how upstream TLS can be configured. We have omitted downstream TLS configuration for simplicity. As noted before, it doesn't matter how downstream TLS is configured for the specific listener or route. kind: BackendPolicy apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: my-app annotations: networking.x-k8s.io/app-protocol: https spec: backendRefs: - name: my-service group: core kind: Service port: 443 tls: certificateAuthorityRef: name: my-cluster-ca group: core kind: Secret options: {} --- apiVersion: v1 kind: Service metadata: name: my-service spec: ports: - name: http port: 80 targetPort: 8000 - name: https port: 443 targetPort: 8443 selector: app: my-service --- kind: HTTPRoute apiVersion: networking.x-k8s.io/v1alpha1 metadata: name: my-service-route spec: hostnames: - \"foo.com\" rules: - matches: - path: type: Prefix value: / forwardTo: - serviceName: my-service port: 8443","title":"Example"},{"location":"tls/#extensions","text":"Both upstream and downstream TLS configs provide an options map to add additional TLS settings for implementation-specific features. Some examples of features that could go in here would be TLS version restrictions, or ciphers to use.","title":"Extensions"}]}